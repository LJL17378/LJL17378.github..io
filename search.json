[{"title":"修饰符","path":"/2024/09/22/修饰符/","content":"what is 修饰符在vue中，修饰符处理了很多DOM事件的细节，可以让我们专注于逻辑处理和方法实现，免于疲于DOM事件的细节vue中修饰符主要分为以下五类： 表单修饰符 事件修饰符 鼠标按键修饰符 键值修饰符 v-bind修饰符 常见的修饰符表单修饰符 lazy trim number lazy 默认情况下，v-model会在每次input事件更新数据。可以通过添加lazy修饰符来改为在每次change事件之后更行数据： 12&lt;input type=&quot;text&quot; v-model.lazy=&quot;value&quot;&gt;&lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; trim 可以通过在v-model后添加.trim修饰符来自动去除用户输入内容中两端的空格： 1&lt;input type=&quot;text&quot; v-model.trim=&quot;value&quot;&gt; number 可以自动把用户输入的内容转换为数字： 1&lt;input type=&quot;number&quot; v-model.number=&quot;age&quot;&gt; 事件修饰符 stop prevent self once capture passive native stop 使用.stop可以阻止点击事件冒泡： 123&lt;div @click=&quot;divClick&quot;&gt; &lt;button @click.stop=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 这样在点击按钮的时候就不会触发到父元素的divClick事件2. prevent 阻止了事件的默认行为，例如提交事件之后不会再重新加载页面，再例如点击链接之后不会自动跳转到对应的页面： 12&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;aClick&quot;&gt;点击不跳转&lt;/&gt; self 仅当事件处理的目标是元素本身的时候才会触发事件处理器，例子： 123456789id=&quot;_Red&quot; v-on:click=&quot;doThat1(event)&quot; style=&quot;width: 500px;height: 500px;background: red;&quot;&gt; &lt;div v-on:click=&quot;doThat(event)&quot; id=&quot;_Blue&quot; style=&quot;width: 200px;height: 200px;background: blue;&quot;&gt; &lt;/div&gt; &lt;/div&gt; vue 实例方法 12345678910doThat:function(e)&#123; alert(&#x27;doThat&#x27;+$(e.target).attr(&#x27;id&#x27;)); &#125;,doThat1:function(e)&#123; alert(&#x27;doThat1&#x27;+$(e.target).attr(&#x27;id&#x27;)); &#125; 没有添加修饰符的时候，点击blue部分的输出结果是： 123doThat_BluedoThat1_Blue//这里要说明一下，事件冒泡除了事件触发以外传入的事件对象也是事件源的对象，并非是事件绑定的元素，因此两次输出的都是Blue而不是一次Blue一次Red 当我们再Red上加上.self修饰符的时候再点击Blue就会发现只输出了doThat_Blue就不会再输出了，因为.self只执行直接作用在该元素上的事件。注意：使用修饰符时需要注意调用顺序，使用@click.prevent.self会阻止元素及其子元素的所有点击事件的默认行为而@click.self.prevent则只会阻止对元素本身的点击事件的默认行为。4. once 绑定了事件以后就只能触发一次，第二次就不会触发了。 1&lt;button @click.once=&quot;shout(1)&quot;&gt;ok&lt;/button&gt; capture 当元素发生冒泡时先处理带有.capture的事件，如果有多个事件带有该修饰符则从外向内逐个处理，而没有带该修饰符的就会从内向外处理： 12345678910111213 &lt;div @click.capture=&quot;shout(1)&quot;&gt; obj1&lt;div @click.capture=&quot;shout(2)&quot;&gt; obj2&lt;div @click=&quot;shout(3)&quot;&gt; obj3&lt;div @click=&quot;shout(4)&quot;&gt; obj4&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;// 输出结构: 1 2 4 3 6. passive 在移动端，当我们在监听元素滚动的时候，会一直触发onscroll事件让我们的网页变卡，在使用了这个修饰符之后就相当于给onscroll事件添加了一个.lazy修饰符。 .passive修饰符一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能。注意：不要同时使用.passive和.prevent7. native 让组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件 1&lt;my-component v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt; 鼠标按钮修饰符鼠标按钮修饰符针对的就是左键，中键，右键点击，有如下： left 左键点击 right 右键点击 middle 中间点击 123&lt;button @click.left=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;&lt;button @click.right=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;&lt;button @click.middle=&quot;shout(1)&quot;&gt;ok&lt;/button&gt; 键盘修饰符键盘修饰符就是用来修饰键盘事件的，用来检查特定的键盘按键，我们可以在v-on或者@监听按键事件的时候添加按键修饰符。 1234//仅在 `key` 为 `Enter` 时调用 `submit`，同理可以使用别的按键别名&lt;input @keyup.enter=&quot;submit&quot; /&gt;&lt;input @keyup=&quot;submit&quot; /&gt;//在按下键盘任意键的时候触发事件 按键别名 .enter .tab .delete(Delete or Backspace) .esc .up .down .left .right 系统按键修饰符 .ctrl .alt .shift .meta(windows里面就是windows键) 举例来说： 12345&lt;!-- Alt + Enter --&gt;&lt;input @keyup.alt.enter=&quot;clear&quot; /&gt;&lt;!-- Ctrl + 点击 --&gt;&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt; .exact修饰符12345678&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt; v-bind修饰符有 async prop camel 等，不太懂其意义，以后再说吧"},{"title":"vue小记","path":"/2024/09/22/小记（1/","content":"计算属性缓存将同样的函数定义为方法而不是计算属性时，两种方法的结果上时一致的，而计算属性会基于其响应式依赖被缓存只有在其响应式依赖变更的时候才会重新计算，但是方法在每次访问的时候都会重复执行函数。 样式绑定绑定数组我们可以通过给:class绑定一个数组来渲染多个css 1&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt; 相应的，也能在数组里面用对象或者三目表达式来进行有选择的渲染 123&lt;div :class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;//`isActive`为真时active被渲染&lt;div :class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;//errorClass会一直存在 组件绑定 根元素 在给组件绑定时，如果组件只有一个根元素，那么就会直接给这个根元素渲染 当有多个根元素时，就可以通过@attrs属性来实现指定： 123&lt;!-- MyComponent 模板使用 $attrs 时 --&gt;&lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;&lt;span&gt;This is a child component&lt;/span&gt; 1&lt;MyComponent class=&quot;baz&quot; /&gt; 会被渲染成： 12&lt;p class=&quot;baz&quot;&gt;Hi!&lt;/p&gt;&lt;span&gt;This is a child component&lt;/span&gt; 内联样式:style支持绑定javascript对象值，对应的时html元素的style属性： 12const activeColor = ref(&#x27;red&#x27;)const fontSize = ref(30) 1&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; 绑定对象可以通过直接绑定一个对象来使模板更加简洁： 1234const styleObject = reactive(&#123; color: &#x27;red&#x27;, fontSize: &#x27;13px&#x27;&#125;) 1&lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt; 绑定数组可以通过绑定多个数组来合并并且渲染到同一个元素上面： 1&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 列表渲染12345678&lt;li v-for=&quot;&#123; message &#125; in items&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/li&gt;&lt;!-- 有 index 索引时 --&gt;&lt;li v-for=&quot;(&#123; message &#125;, index) in items&quot;&gt; &#123;&#123; message &#125;&#125; &#123;&#123; index &#125;&#125;&lt;/li&gt; 单大括号内与对象的属性名保持一致 v-for与对象你也可以使用 v-for 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 Object.keys() 的返回值来决定。 12345const myObject = reactive(&#123; title: &#x27;How to do lists in Vue&#x27;, author: &#x27;Jane Doe&#x27;, publishedAt: &#x27;2016-04-10&#x27;&#125;) 12345&lt;ul&gt; &lt;li v-for=&quot;value in myObject&quot;&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 第二个参数表示属性名，第三个参数表示位置索引 123&lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/li&gt; v-if 与 v-for同一个节点上，v-if的优先级比v-for高，所以将无法读取到别名 1234567&lt;!-- 这会抛出一个错误，因为属性 todo 此时 没有在该实例上定义--&gt;&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo.name &#125;&#125;&lt;/li&gt; 方法事件处理器v-on可以接收一个函数名来对函数调用 123456789const name = ref(&#x27;Vue.js&#x27;)function greet(event) &#123;//event可以删去 alert(`Hello $&#123;name.value&#125;!`) // `event` 是 DOM 原生事件 if (event) &#123;//当事件发生时 alert(event.target.tagName)//event.target.tagName访问dom元素 &#125;&#125; 12&lt;!-- `greet` 是上面定义过的方法名 --&gt;&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt; 一点例子1234567891011&lt;script setup&gt;defineProps([&#x27;title&#x27;])defineEmits([&#x27;remove&#x27;])&lt;/script&gt;&lt;template&gt; &lt;li&gt; &#123;&#123; title &#125;&#125; &lt;button @click=&quot;$emit(&#x27;remove&#x27;)&quot;&gt;Remove&lt;/button&gt; &lt;/li&gt;&lt;/template&gt;"},{"path":"/2024/09/22/第一次正式例会学习/","content":"title:学线前端第一次例会正式学习文档有关vue组合式API 由于自学的时候我学的是选项式API，所以现在需要学习组合式，组合式简单了许多，甚至不需要default export，真方便挺多的，牛魔的 在组合式API中，使用ref()函数来声明响应式状态 1234&lt;script setup&gt;//在script中添加一个`setup`以实现响应式import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0); 用ref()函数接收参数，将其包裹在一个带有.value属性的ref对象中返回： 12345console.log(count) // &#123; value: 0 &#125;console.log(count.value) // 0count.value++console.log(count.value) // 1 所以当使用了ref()时，要使用这个值一定要记得加.value而方法等可以直接使用js中的语法，不需要通过methods :包裹在&lt;script setup&gt;...&lt;/script&gt;中可以用import Component from &#39;./components/Component.vue&#39;语句来引用组件，不需要再注册了。而且在父组件之中可以把一个子组件的名字当作标签来使用，此时这个子组件的内容就可以正常显示出来。 计算属性以及解析赋值语法在&lt;script setup&gt;...&lt;/script&gt;中记得import &#123; computed &#125; from &#39;vue&#39;而当有别的需要通过从vue引用时，例如生命周期钩子函数时，可以一并写成: 1import &#123; ref, computed, onMounted &#125; from &#x27;vue&#x27; 以下是使用计算属性的一个实例： 12345678910111213const fullName = computed(&#123; // getter get() &#123; return firstName.value + &#x27; &#x27; + lastName.value &#125;, // setter set(newValue) &#123; // 注意：我们这里使用的是解构赋值语法 const arr = newValue.split(&#x27; &#x27;) firstName.value = arr[0] lastName.value = arr[arr.length - 1] &#125;&#125;) 注意： 这里的get()和set()在使用时不需要另外加上，在调用fullName即自动调用了get()函数，而在fullName = &#39;Tony Stark&#39;时就会自动调用set()函数，这里的&#39;Tony Stark&#39;可以是任何文本。 解构赋值法：通过.split()函数将一段字符串分开储存在一个数组之中，并赋值给firstName和lastName，而后在set()中就会将数据处理然后返回，强调一下需要const firstName = ref(&#39;John&#39;) const lastName = ref(&#39;Doe&#39;)来实现响应式。 计算属性一般是只读的，但是当我们添加了一个get()之后可以通过fullName = &#39;Tony Stark&#39;来进行修改。 生命周期钩子函数每个vue组件实例在被创建的时候都会经历一系列的初始化步骤，在此过程中就会运行被称为生命周期钩子的函数，让开发者可以在特定阶段运行自己的代码。 注册周期钩子1234567&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;//可以和ref,computed等放在一起onMounted(() =&gt; &#123; console.log(`the component is now mounted.`)&#125;)&lt;/script&gt; 一些现在不懂但是应该很重要的东西当调用 onMounted 时，Vue 会自动将回调函数注册到当前正被初始化的组件实例上。这意味着这些钩子应当在组件初始化时被同步注册。例如，请不要这样做： 123456setTimeout(() =&gt; &#123; onMounted(() =&gt; &#123; // 异步注册时当前组件实例已丢失 // 这将不会正常工作 &#125;)&#125;, 100) 注意这并不意味着对 onMounted 的调用必须放在 setup() 或 &lt;script setup&gt; 内的词法上下文中。onMounted() 也可以在一个外部函数中调用，只要调用栈是同步的，且最终起源自 setup() 就可以。 有关npm在一个项目中需要使用到各种依赖包，我们可以在npm官网查看依赖的名字，作用，还能通过学习官方文档来使用依赖因为一般使用的是vscode，所以这里直接用vscode来举例，进入到项目的文件夹过后，点开查看&gt;终端，然后输入命令行npm install 文件名来下载依赖，在vue项目中可以在package.json中看到我们使用的依赖。"},{"title":"第一次自己学vue文档","path":"/2024/09/22/第一次学习文档/","content":"项目结构目前需要了解的 package.json文件中包含的是项目的依赖列表 index.htmlvue应用会通过这个文件进行运行 src是vue应用的核心代码目录 main.js:会初始化vue应用并决定将什么应用挂载到哪个HTML元素上面 App.vue：是vue应用的根节点组件 components：用来存放自定义的组件的目录 assets：这个目录用来存放css和图片的静态资源 App.vueApp.vue中能看到&lt;template&gt;,&lt;script&gt;,&lt;style&gt;三部分，分别包含了组件的模板，脚本和样式相关内容。 &lt;template&gt;包含了所有的标记结构和组件的展示结构，可以包含任何合法的HTML以及vue特定的语法。 &lt;script&gt;包含了组件中的非现实逻辑，但是最重要的是，这个标签要默认导出一个js对象。该对象是你在本地注册组件、定义属性、处理本地状态、定义方法的地方。 main.js12345import &#123; createApp &#125; from &#x27;vue&#x27;//起手式，无需多言，主要是我不知道怎么说import App from &#x27;./App.vue&#x27;//从一个单文件组件导入根组件import &quot;./assets/reset.css&quot;;//导入css文件createApp(App).mount(&#x27;#app&#x27;)//创建一个vue应用并且并且将其挂载起来供HTML使用 组件中&lt;script&gt;内的内容12345678910111213141516171819import ToDoForm from &quot;./components/ToDoForm.vue&quot;;//在注册组件之前需要导入//以下是组件的默认导出内容export default &#123; name: &#x27;App&#x27;//App填写的是组件的 components: &#123; ToDoForm//用来注册组件，和vue文件名称一致 &#125;, data()&#123; return &#123; ToDoItem:&#x27;&#x27;//需要使用到数据，在：对其进行赋值 &#125;, &#125;; methods :&#123; //这里写方法和逻辑 &#125; //还有props和钩子函数以及计算等，等待后面的学习ing&#125; 自定义元素要在应用程序中实际展示 ToDoItem 组件，你需要在 &lt;template&gt; 模板内添加一个 &lt;to-do-item&gt;&lt;/to-do-item&gt; 元素。请注意，组件文件名及其在 JavaScript 中的表示方式总是用大写驼色（例如 ToDoList），而等价的自定义元素总是用连字符小写（例如 &lt;to-do-list&gt;）。 模板语法文本插值&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;双大括号标签中的 msg会被替成相应组件实例中的msg的值，而且每次msg属性改变它也会同步更行这么一想还怪好用的嘞 v-html双大括号会将数据解释为纯文本，而不是HTML。可以使用v-html指令进行插入： 12&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; Attribute如果想要响应式地绑定一个attribute可以通过v-bind进行 1&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 通过v-bind指令将id和dynamicId保持一致，实现响应式的绑定 简写1&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 用:来代替v-bind: 布尔型Attribute布尔型Attribute依据true&#x2F;false决定该attribute是否应该存在在这个元素上&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;当isButtonDisabled为真值或者一个字符串的时候，元素会包含这个attribute。而当为其他或者假值时该attribute将会被忽略 动态绑定多个值12345678data() &#123; return &#123; objectOfAttrs: &#123; id: &#x27;container&#x27;, class: &#x27;wrapper&#x27; &#125; &#125;&#125; 这是一个包含有多个Attribute的javascript对象可以通过不带参数的v-bind来将其绑定到单个元素上：&lt;div v-bind=&quot;objectOfAttrs&quot;&gt;&lt;/div&gt; 使用javascript表达式vue在数据绑定还支持完整的javascript表达式： 1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;div :id=&quot;`list-$&#123;id&#125;`&quot;&gt;&lt;/div&gt; vue模板中在以下场景可以使用JavaScript表达式： 在文本插值中 在以v-为开头的特殊attribute值中。 仅支持表达式12345&lt;!-- 这是一个语句，而非表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 条件控制也不支持，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 可以调用函数123&lt;time :title=&quot;toTitleDate(date)&quot; :datetime=&quot;date&quot;&gt; &#123;&#123; formatDate(date) &#125;&#125;&lt;/time&gt; 内置指令 指令 期望的绑定值类型 作用 v-text string 等同于&#123;&#123;&#125;&#125;对文本进行插值 v-html string 作为HTML值进行插入（最好不用） v-show any 基于表达式的真假性来改变元素的可见性（不会对元素有删除操作） v-if any 基于表达式的真假性来有条件地对元素或者模板片段进行渲染（会对元素有删除操作） v-else 无需输入值 表示v-if或者v-if&#x2F;v-else-if链式调用的else块，上一兄弟元素必须有v-if或者v-else-if v-else-if any 作为else if块被调用，上接v-if或者v-else-if v-for Array&#x2F;Object&#x2F;number&#x2F;string&#x2F;Iterable 基于原始数据地多次渲染元素或者模板快 v-on Function&#x2F;Inline Statements&#x2F;Object 给元素绑定事件监听器(缩写@) v-bind any&#x2F;Object（不带参数） 动态绑定attribute v-model 根据表单的输入元素和组建的输出值而改变 在表单输入元素或组件上创建双向绑定。 多次渲染实例123&lt;div v-for=&quot;item in items&quot;&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt; 监听实例1234567$emit(&quot;todo-added&quot;,this.data)//子组件向父组件传值，其中&quot;todo-added&quot;可以在父组件中绑定事件，this.data则为传递的数据&lt;to-do-form @todo-added=&quot;addToDo&quot;&gt;&lt;/to-do-form&gt;methods:&#123; addToDo(Data)&#123;运行代码//其中Data就是this.data传输来的数据&#125;,&#125;; 实例其二 1234567 &lt;button type=&quot;submit&quot; v-on:click=&quot;$emit(&#x27;deleted&#x27;)&quot; class=&quot;btn-del&quot;&gt;Delete&lt;/button&gt;//子组件@deleted=&quot;deleteItem(item.id)&quot;//在父组件的自定义标签中添加deleteItem(toDoId)&#123; let toDoToUpdate = this.ToDoItems.find((item) =&gt; item.id === toDoId); toDoToUpdate.show = !toDoToUpdate.show; localStorage.setItem(&#x27;ToDoItems&#x27;, JSON.stringify(this.ToDoItems)); &#125;,//script中的方法 下一次学习目标: props以及更多组件实例 v-slot以及更多vue的内置指令 插槽 动态参数 修饰符 计算属性 生命周期钩子函数"},{"title":"学线前端第三次例会正式学习文档","path":"/2024/09/22/第三次正式例会/","content":"项目结构（新的）components用来装子组件的 assets用来装css图片等资源 router有一个index.js用来装不同的url路径对应的处理函数以及所对应的挂载的组件 store里面装的是一个用来存储不同网页的共同使用的资源的文件 views里面装的是组件的视窗部分，就是给路由用的 reactive和ref函数 ref reactive 数据类型 原始数据、对象 对象 操作 js中需要添加.value，tamplate中则不用 都不用添加.value watch监听1234watch(count, (newCount, oldCount) =&gt;&#123; console.log(`count change from $&#123;oldCount&#125; to $&#123;newCount&#125;`);&#125;)//count 的位置可以填对象，基本数据，计算属性等 立即执行123456789watch( zzy, () =&gt; &#123; console.log(&quot;zzy changed&quot;); &#125;, &#123; immediate: true, &#125;); 深度监听当你监听的是一个对象而且没有进行深度监听的时候，当对象的某个属性值改变的时候是不会触发监听事件的。这个时候就要加上一个&#123;deep:true,&#125; 123456789watch( zzy, (newZzy, prevZzy) =&gt; &#123; console.log(`zzy changed from $&#123;prevZzy.age&#125; to $&#123;newZzy.age&#125;`); &#125;, &#123; deep: true, &#125;); 多重监听主要是把单个名字改成一个数组形式， 12345678910watch( [count, zzy], ([newCount, newZzy], [prevCount, prevZzy]) =&gt; &#123; console.log(`多重监听count changed from $&#123;prevCount&#125; to $&#123;newCount&#125;`); console.log(`多重监听zzy changed from $&#123;prevZzy.age&#125; to $&#123;newZzy.age&#125;`); &#125;, &#123; deep: true, &#125;); 监听单个属性123456watch( () =&gt; zzy.value.age, (newAge, prevAge) =&gt; &#123; console.log(`zzy.age changed from $&#123;prevAge&#125; to $&#123;newAge&#125;`); &#125;); 使用箭头函数作为watch的回调函数可以让我们再函数内部访问到变化前后的属性值 templateRef 需要在你想要调用的元素的标签名里面加上ref = index（这是一个别名） 在&lt;script setup&gt;里面写上const index = ref(null)这里写上null并没关系。 调用templateRef1234567891011121314151617&lt;div ref=&quot;index&quot;&gt; &lt;h1&gt;templateRef模板引用&lt;/h1&gt; &lt;p&gt;打开控制台查看&lt;/p&gt; &lt;/div&gt;//以下是scriptimport &#123;ref&#125; from &#x27;vue&#x27;const index = ref(null)function handleClick() &#123; console.log(index.value)&#125;//以下是在控制台的输出结果&lt;div ref=&quot;index&quot;&gt; &lt;h1&gt;templateRef模板引用&lt;/h1&gt; &lt;p&gt;打开控制台查看&lt;/p&gt; &lt;/div&gt; 实现dom树的修改 1234function changeColor() &#123; if(index.value.style.color == &#x27;red&#x27;)index.value.style.color = &#x27;blue&#x27; else index.value.style.color = &#x27;red&#x27;&#125; 父子组件通信子组件向父组件传输数据defineEmits12345const emit = defineEmits([&#x27;pass-msg-to-father&#x27;])const msg2 = ref(666)onMounted(()=&gt;&#123; emit(&#x27;pass-msg-to-father&#x27;, msg2)&#125;) 注意：这里emit不可以随便修改，两个都是！在父组件中子组件的标签内用@pass-msg-to-father = &quot;getMagFromSon&quot;自己定义的一个方法名在&lt;script setup&gt;中添加 1234const msg2 = ref(&#x27;&#x27;)const getMagFromSon = (data) =&gt; &#123; msg2.value = data.value&#125; 来实现子组件向父组件的通信当然，这里的data也是一个别名 defineExpose（学长甄选，更加符合直觉，我也是这么觉得滴）1234defineExpose(&#123; sonMsg, changeSonMsg&#125;) 这里的sonMsg和changeSonMsg等就是已经在子组件已经定义的变量和函数然后再在父组件的script里面加上这几句,其实就是你平时怎么用就怎么用就好了 123456const getMsgFromSon2 = () =&gt; &#123; console.log(son2.value.sonMsg) son2.value.changeSonMsg() son2Msg.value = son2.value.sonMsg console.log(son2.value.sonMsg)&#125; 父组件向子组件的通信defineProps在子组件当中创建一个props对象 123456const props = defineProps(&#123; msg: &#123; type: Number, required: true &#125;&#125;) 这里的defineProps就相当于给子组件添加了新的属性然后再在父组件当中的子组件标签当中用v-bind实现双向绑定，然后再再父组件中添加const msg = ref(0)等语句就可以实现父组件给子组件传值。 祖孙组件传值provide and inject 12345678import &#123; provide, ref &#125; from &#x27;vue&#x27;;const count = ref(0);const addCount = () =&gt; &#123; count.value++;&#125;provide(&#x27;count&#x27;, count);provide(&#x27;addCount&#x27;, addCount); 只要在祖组件当中使用过一次provide子组件和孙组件等只需要inject就可以共享使用变量和方法了 1234567&lt;script setup&gt;import sonComponent from &#x27;./sonComponent.vue&#x27;;import &#123; inject &#125; from &#x27;vue&#x27;;const count = inject(&#x27;count&#x27;);const addCount = inject(&#x27;addCount&#x27;);&lt;/script&gt; 123456&lt;script setup&gt;import &#123; inject &#125; from &#x27;vue&#x27;;const count = inject(&#x27;count&#x27;);const addCount = inject(&#x27;addCount&#x27;);&lt;/script&gt; 然后只要按照平时使用变量和函数的方法正常使用就没有问题了 pinia是vue专属的最新的状态管理库，允许跨组件或页面来共享数据的状态 添加pinia项目 命令行添加依赖npm install pinia 在入口文件main.js中引入Pinia123import &#123; createPinia &#125; from &#x27;pinia&#x27;//别的乱七八糟app.use(createPinia()) 使用pinia项目要在专门的store文件夹里面添加不同的文件 12345678910111213import &#123; ref, computed &#125; from &#x27;vue&#x27;import &#123; defineStore &#125; from &#x27;pinia&#x27;export const useCounterStore = defineStore(&#x27;counter&#x27;, () =&gt; &#123; const count = ref(0) const doubleCount = computed(() =&gt; count.value * 2) function increment() &#123; count.value++ &#125; const decrement = () =&gt; count.value-- return &#123; count, doubleCount, increment, decrement &#125;&#125;) 注意: useCounterStore位置是实际引用的时候会使用到的名称 在const前要记得加上export，导入之前自然要先导出，没有疑问的 回调函数的最后记得将需要导出的变量和方法名return出来。 在组件中使用 123456&lt;script setup&gt;import &#123;useCounterStore&#125; from &#x27;@/stores/counter&#x27;const counterStore = useCounterStore()&lt;/script&gt; 然后正常使用就可以了，比如需要用count直接写counterStore.count想要使用，想要使用increment方法就可以直接写counterStore.increment 实践在实际使用的时候只要在创建vue项目的时候选择添加pinia就可以了 router添加router项目创建一个router文件夹，这个文件夹和组件store等在同一层然后在router文件夹里面创建一个index.js文件 index.js在index.js的开头记得加上import &#123; createRouter, createWebHistory &#125; from &#39;vue-router&#39; 12345678910111213141516171819202122const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), routes: [ &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: refAndReactive &#125;, &#123; path: &#x27;/refAndReactive&#x27;, name: &#x27;refAndReactive&#x27;, component: refAndReactive &#125;, &#123; path: &#x27;/computedAndWatch&#x27;, name: &#x27;computedAndWatch&#x27;, component: () =&gt; import(&#x27;../views/computedAndWatch.vue&#x27;) &#125;, ]&#125;)export default router 这是路由的模板，有两种挂载组件的方法，可以在一开始导包import refAndReactive from &#39;../views/refAndReactive.vue&#39;然后在路由当中用component: refAndReactive直接挂载，但是如果每次都一次性导包，效率未免有些低，所以可以用component: () =&gt; import(&#39;../views/computedAndWatch.vue&#39;)让其在实际使用的时候才挂载起来 组件中使用1234567891011121314151617181920212223242526272829303132333435import &#123; RouterLink, RouterView &#125; from &#x27;vue-router&#x27;const List = [ &#123; url:&#x27;/refAndReactive&#x27;, name: &#x27;响应式和ref与reactive&#x27; &#125;, &#123; url:&#x27;/computedAndWatch&#x27;, name: &#x27;computed和watch&#x27; &#125;, &#123; url:&#x27;/tamplateRef&#x27;, name: &#x27;templateRef模板引用&#x27; &#125;, &#123; url:&#x27;/lifeCycle&#x27;, name: &#x27;生命周期函数&#x27; &#125;, &#123; url: &#x27;/defineProps&#x27;, name: &#x27;父子组件通信&#x27; &#125;, &#123; url: &#x27;/provideAndInject&#x27;, name: &#x27;祖孙组件通信&#x27; &#125;, &#123; url: &#x27;/pinia&#x27;, name: &#x27;pinia&#x27; &#125;, &#123; url: &#x27;/router&#x27;, name: &#x27;router&#x27; &#125;] 从vue-router导入RouterLink和RouterView等，然后创建一个数组，存储url和name然后使用 1&lt;router-link :to=&quot;item.url&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/router-link&gt; 来创建链接实现跳转，item.url就是要跳转的url不过是在App.vue的基础上跳转的，item.name就是相对的名字等 1&lt;router-view&gt;&lt;/router-view&gt; 这个就是用来展示views的视窗 v-on绑定1&lt;button @click=&quot;$router.push(&#x27;/refAndReactive&#x27;)&quot;&gt;点击返回refAndReactive&lt;/button&gt; 使用v-on绑定事件$router.push(&#39;url&#39;)就可以直接跳转到对应的页面 useRouter12345678&lt;script setup&gt;import &#123; useRouter &#125; from &#x27;vue-router&#x27;const router = useRouter()const toPage = (url) =&gt; &#123; router.push(url)&#125;&lt;/script&gt; 1&lt;button @click=&quot;toPage(&#x27;/computedAndWatch&#x27;)&quot;&gt;点击返回computedAndWatch&lt;/button&gt; &#39;/computedAndWatch&#39;处也是填入对应的url"}]