[{"title":"前端培训一","path":"/2024/09/22/前端培训一/","content":"前端第一次培训-HTML,CSS基础前端三剑客之HTML标记语言HTML（Hyper Text Markdown Language）即超文本标记语言，使用标签来描述网页，是网页的骨架部分 标记语言说白了就是让计算机读取的语言，只是告诉计算机那里有个“东西”，让计算进行渲染等处理，以及定义了这些“东西”是什么，以及它们应该如何被呈现或处理 你的第一个HTML元素 在创建一个后缀为html的文件过后，在vscode中打开，输入!并且按下回车，可以帮助你快捷创建一个html页面的框架 and,只有在body里面的内容才会在页面中被展示出来，别的部分会被隐藏，在这里暂时不展开讨论 那么我们自然是要在&lt;body&gt;标签的中间添加我们的元素 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.o&quot;&gt; &lt;title&gt;这是一个HTML页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 你好 html &lt;p&gt;hello html&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; html中的元素一般都会被一对标签包围，但是如果不用标签包围写文字的话也会被显示出来 标签的结构在HTML中一个元素通常由一对标签构成，这对标签包括一个开始标签（Opening Tag）和一个结束标签（Closing Tag）我们需要注意到不同标签的名称不同，而且标签具有特定的属性给我们设置。 一些常用的标签以及属性 标题 &lt;h&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;h2&gt;二级标题&lt;/h2&gt; ...... &lt;h6&gt;六级标题&lt;/h6&gt; 1234567 - 标题文字大小, 从h1到h6逐渐减小- 段落 `&lt;p&gt;` - ```html &lt;p&gt;这是一个段落&lt;/p&gt; 段落之间会换行, 且存在间隔 换行 &lt;br&gt; &lt;p&gt;第一段&lt;br&gt;第二段&lt;/p&gt; 1234567- 水平线 `&lt;hr&gt;` - ```html &lt;p&gt;段落一&lt;/p&gt; &lt;hr&gt; &lt;p&gt;段落二&lt;/p&gt; 划分区域, 提高美观性. 超链接 &lt;a&gt; &lt;a href=&quot;https://www.bilibili.com/&quot;&gt;去B站的超链接&lt;/a&gt; &lt;a href=&quot;https://developer.mozilla.org/zh-CN/&quot; target=&quot;_blank&quot;&gt;学习前端开发&lt;/a&gt; 1234567891011121314 - 点击后跳转到指定网址的网页. - 标签属性: **[📌📌加了中括号的属性表示对应属性是可选属性, 可以不写]** - `href`: 指定要跳转到的目标网址 - `[target]`: 跳转的行为类型. 默认值是`&quot;_self&quot;`, 即将当前标签页替换为新网址; 设置为`&quot;_blank&quot;`后能在新标签页打开网址- 媒体标签: 图片 `&lt;img&gt;`, 音频 `&lt;audio&gt;`, 视频 `&lt;video&gt;` - ```html &lt;img src=&quot;图片路径&quot; alt=&quot;加载失败时显示的文字&quot; width=&quot;100&quot; height=&quot;150&quot;&gt; &lt;audio src=&quot;音频路径&quot; controls loop autoplay muted&gt;&lt;/audio&gt; &lt;video src=&quot;视频路径&quot; controls loop autoplay muted width=&quot;&quot; height=&quot;&quot;&gt;&lt;/video&gt; &lt;img&gt;标签属性: src: 资源路径URL, 可以填图片网址或者本地文件路径 alt: 备用文本描述. 简单说就是图片因为加载出错或者用户省流量等各种原因不显示时才出现的文字 [width], [height]: 图像尺寸, 单位是像素(px) &lt;audio&gt;标签属性: src: 资源路径 [controls]: 是否显示控件 (比如播放&#x2F;暂停按钮等, audio标签最好加上该属性, 不然看不到播放进度条) [loop]: 是否循环播放 [autoplay]: 是否一进页面就自动播放 [muted]: 是否静音播放 &lt;video&gt;标签属性: 基本同&lt;audio&gt;, 不过也可以设置[width], [height]属性来设置尺寸 ​\t🤔🤔为什么像controls, loop这些属性只用写一个属性名, 不用赋值的? ​ 因为这些属性值只接受布尔值 (boolean, 只有两个值: true✅, false❎). 不写属性名就是false, 写上了就是true ​\t📌width和height属性的细节: 只设置其中一项的话, 另一项属性会自动按原图&#x2F;视频比例缩放.​\t如果两项都设置了, 图像可能会拉伸变形. 按钮 &lt;button&gt; &lt;button disabled&gt;这是一个按钮&lt;/button&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 - 用户点击之后就会激活一些功能. 一般要**配合JavaScript使用**, 下次培训会讲 - 标签属性: - `[disabled]`: 是否禁用按钮- 表单系列标签 - `&lt;input&gt;`系列标签. 用于让用户输入信息, 比如用户名密码什么的 其**必选**属性`type`决定了表单的种类: | type属性值 | 说明 | | ---------- | ---------------------------------------------- | | text | 文本框, 用于输入单文本 | | password | 密码框, 输入的内容显示为黑点点●●● | | radio | 单选框, 用于多选一, **注意要设置name属性一样** | | checkbox | 多选框, 用于多选多, **注意要设置name属性一样** | | file | 文件选择, 用于上传文件 | | submit | 提交按钮, **需要配合JavaScript, form标签食用** | - 标签属性: - `text`, `password`: - `[placeholder]`: 输入框占位符, 用于提示用户 - `file`: - `[multiple]`: 是否允许上传多个文件 - 所有类型: - `[name]`: 该表单项的名称, 用来约束单选/多选框或者配合JavaScript区分不同的表单项 - 栗子: ```html &lt;h2&gt;不同种类的表单标签&lt;/h2&gt; &lt;hr&gt; &lt;!-- 应用占位符placeholder --&gt; 文本框, 用于输入单行文本: &lt;input type=&quot;text&quot; placeholder=&quot;随便输入点什么东西&quot;&gt; &lt;hr&gt; 密码框, 用于输入密码: &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot;&gt; &lt;hr&gt; &lt;strong&gt;单选框, 用于多选一: &lt;/strong&gt; &lt;br&gt; 性别: &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;女 &lt;br&gt; 工资收入: &lt;br&gt; ＜3000 &lt;input type=&quot;radio&quot; name=&quot;income&quot;&gt;&lt;br&gt; 3000~6000 &lt;input type=&quot;radio&quot; name=&quot;income&quot; checked&gt;&lt;br&gt; 6000~10000 &lt;input type=&quot;radio&quot; name=&quot;income&quot;&gt;&lt;br&gt; ＞10000 &lt;input type=&quot;radio&quot; name=&quot;income&quot;&gt;&lt;br&gt; &lt;hr&gt; &lt;strong&gt;多选框, 用于多选多: &lt;/strong&gt; &lt;br&gt; 爱好的运动: &lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt;乒乓球&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt;羽毛球&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt;篮球&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt;足球&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt;网球&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt;排球&lt;br&gt; &lt;hr&gt; &lt;strong&gt;文件选择, 用于上传文件: &lt;/strong&gt; &lt;br&gt;上传单个文件: &lt;input type=&quot;file&quot; name=&quot;&quot;&gt; &lt;br&gt;上传多个文件: &lt;input type=&quot;file&quot; name=&quot;&quot; multiple&gt; &lt;hr&gt; 下拉菜单 &lt;select&gt; 相关子级标签: &lt;option&gt; 菜单选项 栗子: 12345678&lt;h2&gt;下拉菜单&lt;/h2&gt;&lt;hr&gt;所在省份:&lt;select&gt; &lt;option value=&quot;001&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;002&quot; selected&gt;上海&lt;/option&gt; &lt;option value=&quot;003&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;004&quot;&gt;深圳&lt;/option&gt;&lt;/select&gt; 标签属性: value: option选项的实际值. 比如北京在后台对应的数据是001, 此时value就是001 [selected]: 有该属性的option选项会被默认选中 文本域 &lt;textarea&gt; 用户可以输入多行内容. 栗子: 1&lt;textarea placeholder=&quot;输入多行文本&quot;&gt;&lt;/textarea&gt; 标签属性: placeholder: 占位文本 列表 &lt;ul&gt;, &lt;ol&gt; &lt;ul&gt;为无序列表, &lt;ol&gt;为有序列表 列表项为 &lt;li&gt; 栗子: 12345&lt;ul&gt; &lt;li&gt;one&lt;/li&gt; &lt;li&gt;two&lt;/li&gt; &lt;li&gt;three&lt;/li&gt;&lt;/ul&gt; 分区 &lt;div&gt; &lt;span&gt; 给页面进行区域划分, 或者划分标签的层级, 并无其他特殊作用div独占一行, span一行可以排列多个 注释 &lt;!-- xxx --&gt; 程序员留下的评论, 说明等信息, 不是标签而是一种语法 以下列举一些比较常用的标签以及属性，想必是列举不全的，可以上MDN了解更多 语义化标签 概念：标签名称拥有自己的含义. 例如:虽然 &lt;div&gt; 和 &lt;p&gt; 标签都会独占一行, 但是 &lt;div&gt; 仅作划分区域用, 无特殊含义; 而 &lt;p&gt; 含义是段落 (paragraph) 可读性更好，使代码结构清晰，方便阅读（不要到处都用div） 前端三剑客之CSS CSS(Cascading Style Sheets)即层叠样式表, 是决定页面「外观」的重要部分。 是可以用来控制元素的尺寸颜色和布局等的样式语言 例如说background-color可以控制对应元素的背景颜色，font-size就可以调整元素内字体的大小，width和height等就可以调整元素的大小。特别的，当你在调整元素的大小的时候可以尝试使用max-height,min-width这些属性以及50%,1vh,1vw这些特殊单位的长度来实现响应式的布局（即根据页面的尺寸来动态地调整页面的布局） CSS的格式123456CSS选择器 &#123; CSS属性名称: CSS属性值; CSS属性名称1: CSS属性值1; ...... /* CSS注释 */&#125; CSS属性实在是太多了，而且CSS的属性确实像是英语，需要积累，对此我们的建议是多看多用多查，查多了用多了就记下来了。 使用CSS的方法 行内样式 直接在标签的style属性内些CSS属性值 1&lt;p style=&quot;background-color: orange; font-size: 40px&quot;&gt;一段文字&lt;/p&gt; style标签样式 在&lt;head&gt;标签内嵌套一个&lt;style&gt;标签或者在&lt;html&gt;标签外写一对&lt;style&gt;标签，再在其中写入CSS属性：123456789101112&lt;head&gt; &lt;!-- ... --&gt; &lt;style&gt; .paragraph &#123; background-color: orange; font-size: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;paragraph&quot;&gt;一段文字&lt;/p&gt;&lt;/body&gt; 外联样式 另写一个.css文件, 然后在html页面的&lt;head&gt;标签内使用&lt;link&gt;标签引入:12345/* in style.css */.paragraph &#123; background-color: orange; font-size: 40px;&#125; 1234567&lt;!-- in index.html --&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css的相对路径&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;paragraph&quot;&gt;一段文字&lt;/p&gt;&lt;/body&gt; CSS选择器 如果每个元素的都用行内样式来填写一大堆属性是否看起来可读性太差？如果每个样式相同的元素都使用复制粘贴来的行内样式修改起来起来是否太过痛苦？在我写了style标签样式之后该怎么确定会在那些元素上生效？ 这一切的答案都指向了CSS选择器 选择器的分类 标签名选择器 直接写标签的名称，然后跟CSS:1234p &#123; /* 把所有的p标签都加上下面的样式 */background-color: orange;font-size: 40px;&#125; 类名选择器 先给元素设置类名属性: class&#x3D;”xxx” , 然后CSS中用 .类名 的格式来选择对应元素栗子见上文 style标签样式 设置多个类名时, 用空格隔开: class=&quot;类名1 类名2 类名3 ...&quot; id选择器 先给元素设置id属性: id&#x3D;”xxx” , 然后CSS中用 #id 的格式来选择对应元素 一个页面中只能有一个id为xxx的元素123456789101112&lt;head&gt; &lt;!-- ... --&gt; &lt;style&gt; #p1 &#123; background-color: orange; font-size: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;p1&quot;&gt;一段文字&lt;/p&gt;&lt;/body&gt; 选择器的权重:标签选择器 &lt; 类选择器 &lt; id选择器 &lt; 行内样式 复合选择器 后代选择器 选择器1 选择器212.outer .inner &#123;...&#125;/* 带有outer类名的元素中, 所有带inner类名的后代(包括子代, 孙代, ...)都会被选中 */ 子代选择器 选择器1 &gt; 选择器2 12345678910111213141516 .outer &gt; #inner &#123;...&#125; /* 带有outer类名的元素中, 只有id为inner的子代(F1, 不包括孙代, 曾孙代...)才会被选中，不限制标签类型 */ ``` 3. 交集选择器 - `选择器1选择器2`(注意交集选择器没有中间那个空格) ```css p#inner &#123;...&#125; /* 只有是p而且带有inner这个id的元素才会被选中 */ ``` 4. 并集选择器 - `选择器1，选择器2` ```css .outer, .inner &#123;...&#125; /* 带有outer或inner类名的元素都会被选中, 适合简化重复的CSS */ vscode中编写HTML时的一些快捷表达 !: 快速生成一个!DOCTYPE声明 输入标签名自动补齐12345&lt;!-- 输入 h1 , 按回车自动补全 --&gt;&lt;h1&gt;&lt;/h1&gt;&lt;!-- 输入 h1&#123;填充文本&#125; , 按回车自动补全 --&gt;&lt;h1&gt;填充文本&lt;/h1&gt;其它标签也是同理 使用#输入id.输入class[]输入属性12345&lt;!-- 输入 div.class1#id1 , 按回车自动补全 --&gt;&lt;div class=&quot;class1&quot; id=&quot;id1&quot;&gt;&lt;/div&gt;&lt;!-- 输入 div[attr=value] , 按回车自动补全 --&gt;&lt;div attr=&quot;value&quot;&gt;&lt;/div&gt;其它标签也是同理 使用*快速生成多个元素1234&lt;!-- 输入 div.class1*3 , 按回车自动补全 --&gt;&lt;div class=&quot;class1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;class1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;class1&quot;&gt;&lt;/div&gt; 使用&gt;输入嵌套标签,+生成兄弟标签，用()进行分组123456789&lt;!-- 输入 div&gt;p , 按回车自动补全 --&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;!-- 输入 div&gt;(p+img) , 按回车自动补全 --&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;img src=&quot;&quot; alt=&quot;&quot;&gt;&lt;/div&gt; CSS的层叠性在 1234.outer&#123; background-color:orange; background-color:yellow;&#125; 和 123456.outer&#123; background-color:orange;&#125;.outer&#123; background-color:yellow;&#125; 的情况下，.outer最终会是什么颜色？ 在层叠样式表篇中，如果给一个元素设置了重复的CSS属性，此时就会发生层叠（覆盖），写在后面的就会覆盖掉前面的,那么在这种情况之下,.outer最终就会是黄色背景了。 常用的CSS属性和定位和布局有关的属性在这里暂时没有涉及 属性名称 说明 width 宽度 height 高度 color 字体的颜色 font-size 字体大小 font-family 选用的字体 text-align 文本对齐方式 line-height 行高 border 边框 border-radius 边框的圆角半径 opacity 元素的不透明度 background-color 背景颜色 除此之外当然还有很多，前面的区域还是交给你们自己去探索吧 使用浏览器来调试 在样式可能存在问题或者说不够美观的情况下，如果进行频繁的修改的话未免有些麻烦了🤯🤯🤯，那么有同学就要问了，学长学长，有没有什么办法在不修改html文件的情况下修改元素还可以修改页面元素和属性并且可以即时看到修改效果的办法呢？ 那自然是有的,在浏览器页面当中右键呼出菜单点击”检查”或者点击你键盘上的F12(在某些阵列或者笔记本的键盘上需要你点击Fn+F12orFn+=,视情况而定吧) 你可以在调试工具里面: 修改,增删&#x2F;元素属性&#x2F;子元素 修改.增删元素的CSS属性 CSS盒子模型页面中的每一个元素都可以看作是一个盒子,再次基础上我们可以更方便地进行布局,在浏览器中,渲染元素的时候会把元素看成一个个矩形区域,为什么被叫作盒子模型呢?我相信下面的两张图片是相当形象了.相关的CSS属性: 属性名称 说明 取值 width,height 调整内容content的尺寸 px,vh,vw,百分比等等 margin-top,margin-bottom,margin-left,margin-right 上下左右的外边距 px,vh,vw,百分比等等 padding-top…. 内边距 px,vh,vw,百分比等等 border-top 边框 边框宽度 类型(solid | dashed | dotted) 颜色 特别的,盒子的最终尺寸大小为:content+padding+border 如果我想设置一个100px * 100px的盒子, 但其中又有10px的padding和1px的border, 那宽高就得设置为78px * 78px了. 以后padding和border宽度一变化我还得再改宽高, 简直是麻烦死了! 😩😩😩 你说的对,但是,好吧没有但是,如果你觉得麻烦,那直接给这个盒子设置一个box-sizing属性吧: 1234567.box &#123; box-sizing: border-box; width: 100px; height: 100px; padding: 10px; border: 1px solid black;&#125; CSS盒子模型的速记模式1234567891011121314151617.box &#123;/* 只写一个值, 四个方向都是10px */margin: 10px;/* 两个值: 上下, 左右 */margin: 10px 15px;/* 三个值: 上 左右 下 */margin: 10px 15px 20px;/* 四个值: 上 右 下 左 */margin: 10px 15px 20px 25px;/* padding同理 *//* 四个方向都是宽度为3px的实心红色边框 */border: 3px solid black;&#125; CSS变量（var）与计算(calc())虽然不一定是很常用，但是还是要求能看懂CSS变量是CSS中一个非常强大的功能，它允许我们定义一些变量，然后在样式表中使用这些变量，从而实现对样式的复用和重用。 CSS变量 声明一个CSS变量，格式为--变量名:值; CSS变量可以被继承，即父元素内定义的CSS变量在子元素内也可以使用。故当我们希望一个变量能在整个文档里使用时，只需要在根元素定义变量即可（以下两种方式等价，后一种（伪类）更常用。关于伪类的知识后面会讲到）123456789p &#123; --my-color: pink;&#125;html &#123; --main-color: brown;&#125;:root &#123; --text-color: blue;&#125; var()函数 var()函数可以引用之前定义的变量。 calc()函数 call()函数允许我们在样式表中使用一些数学运算，例如加减乘除等。 但是要注意，+和-运算符两边必须有空白字符。如calc(100% -10px)会被解析成为一个无效的表达式，解析结果是：一个百分比后跟一个负数长度值。 *和/则不需要空白字符，但从规范性来说仍推荐加上空白符。 伪类 伪类用一冒号:表示伪类，如:hover、:active、:focus等。 被添加到一个选择器末尾的关键字，用于指定所选元素的特殊状态。 当你希望所指定的元素在特定状态（如按钮悬停时）下能够呈现出不同的样式时，可以使用伪类伪元素就不多赘述了，想了解可以自行上网了解。 元素的显示模式显示模式的主要分类： 块级元素： 独占一行 可以单独设置宽高，不设置时宽度默认跟父级元素一样, 高度由内容撑开 &lt;p&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;header&gt; &lt;footer&gt; &lt;h1&gt; &lt;h2&gt; ... 行内元素：行内元素不会独占一行，而是按照文本的宽度来显示。 一行可以有多个行内元素 不能设置宽高，其尺寸由内容撑开 &lt;a&gt; &lt;span&gt; ... 行内块元素： 一行可以有多个行内块元素 可以设置宽高 &lt;input&gt; &lt;textarea&gt; &lt;button&gt; &lt;select&gt; &lt;img&gt; ... 弹性模式（在讲弹性盒布局的时候会详细讲讲） 网格模式… 切换元素的显示模式 display的属性值 说明 block 切换为块级元素的显示模式 inline 切换为行内元素的显示模式 inline-block 切换为行内块元素的显示模式 none 隐藏元素 像是： 1234567891011121314&lt;head&gt; &lt;style&gt; .anchor &#123; display: inline-block; background-color: orange; /* 没有display: inline-block;的话下面的width和height就不生效了 */ width: 200px; height: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a class=&quot;anchor&quot; href=&quot;https://www.bilibili.com&quot;&gt;B站传送门&lt;/a&gt;&lt;/body&gt; 布局咱就细说一下弹性盒布局吧弹性盒布局（flexbox）是CSS中一个非常强大的布局方式，它允许我们通过简单的声明就可以实现各种复杂的布局。 flex用于创建横向或是纵向的一维页面布局。 要使用 flexbox，你只需要在想要进行 flex 布局的父元素上应用display: flex ，所有直接子元素都将会按照 flex 进行布局。 flex模型图示 当父元素应用display: flex后，其内部子元素沿着两个轴来布局： 主轴（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 main start 和 main end。 交叉轴（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 cross start 和 cross end。 父元素flex属性设置 flex-direction：调整主轴的方向，交叉轴也会相对应地被修改。 row、column：行、列。 row-reverse、column-reverse：反向的行、反向的列 flex-wrap：当子元素将要溢出父元素时，是否允许换行 wrap：允许换行 nowrap：禁止换行 justify-content：主轴上排列方式 center：居中对齐 flex-start：主轴起始位置布局 flex-end：主轴末尾位置布局 space-between：先两边贴边，再平分剩余空间 space-around：直接平分剩余空间 space-evenly：子元素空隙相等 align-items：交叉轴上排列方式 normal：默认值，在弹性布局中效果和stretch相同 center：居中对齐 flex-start：交叉轴起始位置对齐 flex-end：交叉轴末尾位置对齐 baseline：项目的第一行文字基线对齐 stretch：如果项目未设置高度或设为auto，将占满整个容器的高度；如果设置了高度则无变化，类同于flex-start 子元素flex相关属性设置 使用flex为子元素排版时，各子元素宽度分配计算方式颇为复杂，这里我们只介绍比较基本的计算方法，想要了解更为完善的flex技术可以自行搜索 空间分配相关 flex-grow：当这一行子元素宽度小于父元素宽度，子元素分配剩余空间时的分配比例。默认值0，即不会填充剩余空间 flex-shrink：当这一行子元素宽度大于父元素宽度，子元素分配超出空间时的分配比例。默认值1，即所有子元素收缩同等的长度 flex-basis：设置子元素的宽度 flex-basis和width都可以设置宽度，当两个都有自定义时，浏览器听谁的❓❓ flex布局中宽度的优先级：min-width/max-width &gt; flex-basis &gt; width &gt; 内容支撑 flex：组合属性 flex：flex-grow flex-shrink flex-basis flex：flex-grow flex：flex-grow flex-basis 其他属性 align-self：改变该子元素在交叉轴上的对齐方式 可以在这个小游戏网站上面练习一下 元素的定位文本流和文档流 文档流，从左到右从上到下地显示，float,absolute,relative会脱离文档流 文本流，元素内部的一系列字符的排列规则，即元素内部字符从左到右从上到下显示，absolute,relative会脱离文本流，但float不会脱离文本流 定位 相对定位 绝对定位 固定定位 脱离文档流和文本流，相对于其正常文档流中的位置移动 脱离文档流和文本流，相对于其最近的已定位的祖先元素的位置移动 脱离文档流和文本流，相对于浏览器视口边缘中的位置移动 specially，float虽然脱离了文档流，但是没有脱离文本流，所以会经常用来产生文字环绕效果，float相对于父元素移动，但是子元素的float会消除父元素的float float属性的四个可能值 left将元素浮动到左边 right将元素浮动到左边 none默认值，不浮动 inherit默认值，不浮动 在使用相对定位，绝对定位，固定定位 之后，left,right,top,bottom等属性可以移动元素，这些属性只对定位之后的元素起作用，但是float元素无法移动。（可以自己尝试一下） @import 'vue/fonts.css'; :root { –side-bar-bg-color: #fff; –control-text-color: #777; –font-sans-serif: ‘Ubuntu’, ‘Source Sans Pro’, sans-serif !important; –font-monospace: ‘Fira Code’, ‘Roboto Mono’, monospace !important;} html { font-size: 16px;} body { font-family: var(–font-sans-serif); color: #34495e; -webkit-font-smoothing: antialiased; line-height: 1.6rem; letter-spacing: 0; margin: 0; overflow-x: hidden;} #write { max-width: 860px; margin: 0 auto; padding: 20px 30px 100px;} #write p { line-height: 1.6rem; word-spacing: .05rem;} #write ol li { padding-left: 0.5rem;} #write &gt; ul:first-child,#write &gt; ol:first-child { margin-top: 30px;} body &gt; *:first-child { margin-top: 0 !important;} body &gt; *:last-child { margin-bottom: 0 !important;} a { color: #42b983; font-weight: 600; padding: 0 2px; text-decoration: none;} h1,h2,h3,h4,h5,h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text;} h1:hover a.anchor,h2:hover a.anchor,h3:hover a.anchor,h4:hover a.anchor,h5:hover a.anchor,h6:hover a.anchor { text-decoration: none;} h1 tt,h1 code { font-size: inherit !important;} h2 tt,h2 code { font-size: inherit !important;} h3 tt,h3 code { font-size: inherit !important;} h4 tt,h4 code { font-size: inherit !important;} h5 tt,h5 code { font-size: inherit !important;} h6 tt,h6 code { font-size: inherit !important;} h2 a,h3 a { color: #34495e;} h1 { padding-bottom: .4rem; font-size: 2.2rem; line-height: 1.3;} h2 { font-size: 1.75rem; line-height: 1.225; margin: 35px 0 15px; padding-bottom: 0.5em; border-bottom: 1px solid #ddd;} h3 { font-size: 1.4rem; line-height: 1.43; margin: 20px 0 7px;} h4 { font-size: 1.2rem;} h5 { font-size: 1rem;} h6 { font-size: 1rem; color: #777;} p,blockquote,ul,ol,dl,table { margin: 0.8em 0;} li &gt; ol,li &gt; ul { margin: 0 0;} hr { height: 2px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; overflow: hidden; box-sizing: content-box;} body &gt; h2:first-child { margin-top: 0; padding-top: 0;} body &gt; h1:first-child { margin-top: 0; padding-top: 0;} body &gt; h1:first-child + h2 { margin-top: 0; padding-top: 0;} body &gt; h3:first-child,body &gt; h4:first-child,body &gt; h5:first-child,body &gt; h6:first-child { margin-top: 0; padding-top: 0;} a:first-child h1,a:first-child h2,a:first-child h3,a:first-child h4,a:first-child h5,a:first-child h6 { margin-top: 0; padding-top: 0;} h1 p,h2 p,h3 p,h4 p,h5 p,h6 p { margin-top: 0;} li p.first { display: inline-block;} ul,ol { padding-left: 30px;} ul:first-child,ol:first-child { margin-top: 0;} ul:last-child,ol:last-child { margin-bottom: 0;} blockquote { border-left: 4px solid #42b983; padding: 10px 15px; color: #777; background-color: rgba(66, 185, 131, .1);} table { padding: 0; word-break: initial;} table tr { border-top: 1px solid #dfe2e5; margin: 0; padding: 0;} table tr:nth-child(2n),thead { background-color: #fafafa;} table tr th { font-weight: bold; border: 1px solid #dfe2e5; border-bottom: 0; text-align: left; margin: 0; padding: 6px 13px;} table tr td { border: 1px solid #dfe2e5; text-align: left; margin: 0; padding: 6px 13px;} table tr th:first-child,table tr td:first-child { margin-top: 0;} table tr th:last-child,table tr td:last-child { margin-bottom: 0;} #write strong { padding: 0 1px;} #write em { padding: 0 5px 0 2px;} #write table thead th { background-color: #f2f2f2;} #write .CodeMirror-gutters { border-right: none;} #write .md-fences { border: 1px solid #F4F4F4; -webkit-font-smoothing: initial; margin: 0.8rem 0 !important; padding: 0.3rem 0 !important; line-height: 1.43rem; background-color: #F8F8F8 !important; border-radius: 2px; font-family: var(–font-monospace); font-size: 0.85rem; word-wrap: normal;} #write .CodeMirror-wrap .CodeMirror-code pre { padding-left: 12px;} #write code, tt { padding: 2px 4px; border-radius: 2px; font-family: var(–font-monospace); font-size: 0.92rem; color: #e96900; background-color: #f8f8f8;} tt { margin: 0 2px;} #write .md-footnote { background-color: #f8f8f8; color: #e96900;} &#x2F;* heighlight. *&#x2F;#write mark { background-color: #EBFFEB; border-radius: 2px; padding: 2px 4px; margin: 0 2px; color: #222; font-weight: 500;} #write del { padding: 1px 2px;} .cm-s-inner .cm-link,.cm-s-inner.cm-link { color: #22a2c9;} .cm-s-inner .cm-string { color: #22a2c9;} .md-task-list-item &gt; input { margin-left: -1.3em;} @media print { html { font-size: 13px; } table, pre &#123; page-break-inside: avoid; &#125; pre &#123; word-wrap: break-word; &#125; } .md-fences { background-color: #f8f8f8;} .md-diagram-panel { position: static !important;} #write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border: 0; border-radius: 3px; color: #777777; margin-top: 0 !important;} .mathjax-block &gt; .code-tooltip { bottom: .375rem;} #write &gt; h3.md-focus:before { left: -1.5625rem; top: .375rem;} #write &gt; h4.md-focus:before { left: -1.5625rem; top: .285714286rem;} #write &gt; h5.md-focus:before { left: -1.5625rem; top: .285714286rem;} #write &gt; h6.md-focus:before { left: -1.5625rem; top: .285714286rem;} .md-image &gt; .md-meta { border-radius: 3px; font-family: var(–font-monospace); padding: 2px 0 0 4px; font-size: 0.9em; color: inherit;} .md-tag { color: inherit;} .md-toc { margin-top: 20px; padding-bottom: 20px;} .sidebar-tabs { border-bottom: none;} #typora-quick-open { border: 1px solid #ddd; background-color: #f8f8f8;} #typora-quick-open-item { background-color: #FAFAFA; border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee; border-style: solid; border-width: 1px;} #md-notification:before { top: 10px;} &#x2F;** focus mode *&#x2F; .on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12);} header,.context-menu,.megamenu-content,footer { font-family: var(–font-sans-serif);} .file-node-content:hover .file-node-icon,.file-node-content:hover .file-node-open-state { visibility: visible;} .mac-seamless-mode #typora-sidebar { background-color: var(–side-bar-bg-color);} .md-lang { color: #b4654d;} .html-for-mac .context-menu { –item-hover-bg-color: #E6F0FE;}"},{"title":"培训前须知","path":"/2024/09/22/培训前须知 (1)/","content":"培训前须知前端组成部分 HTML：前端页面的骨架 CSS：前端页面的外观 JavaScript：前端页面的行为 培训将围绕这些主题展开。 你需要准备的工具 工欲善其事，必先利其器。 编辑器你完全可以不安装任何软件，就用记事本罢😡😡😡千万不要像上面说的那样干，不然你会十分痛苦，但是作为刚入门的前端并不需要安装太多的软件。VSCode是前端开发最常用的代码编辑器（轻量、强大、免费），提供自动补全、提示、快捷编辑等十分方便的功能。下载教程 VSCode里面那些好使的插件 Chinese:中文汉化，虽说英语可以说是码农最需要学习的一门语言，但是没事，英语不好的时候咱就汉化呗。 Open in browser：安装之后在vscode里面可以直接右键打开html网页 Live Server：打开网页之后可以实时检测网页的修改，不用每次修改之后都保存再刷新了 Code Runner: 可以在vscode里面直接运行js，java等代码，并且可以实时输出结果 Code Spell Checker: 检查单词拼写是否正确 这个时候可能就有同学要问了： 欸，学长，vscode上面要怎么安装插件啊？🤓 很简单，打开vscode之后，在菜单里面找到扩展，然后搜索你需要安装的插件，然后点击安装即可。 浏览器如果你的电脑已经预装了Edge浏览器，那就不用额外安装别的浏览器了；如果没有的话，可以安装Chrome浏览器，或者Firefox浏览器 MarkDown（推荐掌握）文档格式，用于编写文档，并且markdown有很多便利的功能，例如代码高亮，代码块，表格等等。MarkDown可以让文档写作者专注于文档写作上，不用担心格式的问题，让你的手在文档写作过程中不再需要离开键盘。MarkDown教程 如何自学 说好的包教包会呢？为什么现在还要我自学了？取关了！退群！😡😡😡 咳咳，我们确实是说过包教包会，但是编程本身就非常需要自学，在课上不可能涵盖前端需要学习的所有东西，我们课程的重点还是带同学们认识前端和一些重要概念，在课上的一些东西你只要认知到它的存在就好，在具体使用的时候再去上网查就好了，毕竟开发从来不是闭卷考试，你要是让一个程序员不上网那是真的完蛋了。（免责声明免责声明） 学长学长，我们有哪些学习资源呢？🤓 文档，如MDN（推荐）和菜鸟教程，类似的资源网上还有很多，可以自行查找 Bilibili，在这上面你几乎可以找到任何东西的教程 AI，都什么年代还在用传统学习方法，只要你想，你随时都可以向AI提出疑问，这就需要你去描述问题了，这可以很有效地锻炼你提炼问题关键的能力，在后面的开发沟通中起着十分重要的作用。 学长，有啥问题你都可以问学长，就算学长不懂，学长也会帮你去问他们的学长的（什么递归），有问题欢迎询问前端总监，请自行在纳新群中搜索蓝色空间（梁建麟）和rr（李俊煊） 结语培训课程会在军训结束后才正式开始，大家可以多享受一下军训的欢乐时光（bushi），在培训前同学们可以自己预习预习，多去思考前端各个组成部分的作用。前端开发更像是搭积木，充满趣味，能够实现同学们的各种天马行空。相信同学们一定能轻松愉悦地完成培训，加入我们！😊😊😊 @import 'vue/fonts.css'; :root { --side-bar-bg-color: #fff; --control-text-color: #777; --font-sans-serif: 'Ubuntu', 'Source Sans Pro', sans-serif !important; --font-monospace: 'Fira Code', 'Roboto Mono', monospace !important; } html { font-size: 16px; } body { font-family: var(--font-sans-serif); color: #34495e; -webkit-font-smoothing: antialiased; line-height: 1.6rem; letter-spacing: 0; margin: 0; overflow-x: hidden; } #write { max-width: 860px; margin: 0 auto; padding: 20px 30px 100px; } #write p { line-height: 1.6rem; word-spacing: .05rem; } #write ol li { padding-left: 0.5rem; } #write > ul:first-child, #write > ol:first-child { margin-top: 30px; } body > *:first-child { margin-top: 0 !important; } body > *:last-child { margin-bottom: 0 !important; } a { color: #42b983; font-weight: 600; padding: 0 2px; text-decoration: none; } h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; } h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; } h1 tt, h1 code { font-size: inherit !important; } h2 tt, h2 code { font-size: inherit !important; } h3 tt, h3 code { font-size: inherit !important; } h4 tt, h4 code { font-size: inherit !important; } h5 tt, h5 code { font-size: inherit !important; } h6 tt, h6 code { font-size: inherit !important; } h2 a, h3 a { color: #34495e; } h1 { padding-bottom: .4rem; font-size: 2.2rem; line-height: 1.3; } h2 { font-size: 1.75rem; line-height: 1.225; margin: 35px 0 15px; padding-bottom: 0.5em; border-bottom: 1px solid #ddd; } h3 { font-size: 1.4rem; line-height: 1.43; margin: 20px 0 7px; } h4 { font-size: 1.2rem; } h5 { font-size: 1rem; } h6 { font-size: 1rem; color: #777; } p, blockquote, ul, ol, dl, table { margin: 0.8em 0; } li > ol, li > ul { margin: 0 0; } hr { height: 2px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; overflow: hidden; box-sizing: content-box; } body > h2:first-child { margin-top: 0; padding-top: 0; } body > h1:first-child { margin-top: 0; padding-top: 0; } body > h1:first-child + h2 { margin-top: 0; padding-top: 0; } body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child { margin-top: 0; padding-top: 0; } a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 { margin-top: 0; padding-top: 0; } h1 p, h2 p, h3 p, h4 p, h5 p, h6 p { margin-top: 0; } li p.first { display: inline-block; } ul, ol { padding-left: 30px; } ul:first-child, ol:first-child { margin-top: 0; } ul:last-child, ol:last-child { margin-bottom: 0; } blockquote { border-left: 4px solid #42b983; padding: 10px 15px; color: #777; background-color: rgba(66, 185, 131, .1); } table { padding: 0; word-break: initial; } table tr { border-top: 1px solid #dfe2e5; margin: 0; padding: 0; } table tr:nth-child(2n), thead { background-color: #fafafa; } table tr th { font-weight: bold; border: 1px solid #dfe2e5; border-bottom: 0; text-align: left; margin: 0; padding: 6px 13px; } table tr td { border: 1px solid #dfe2e5; text-align: left; margin: 0; padding: 6px 13px; } table tr th:first-child, table tr td:first-child { margin-top: 0; } table tr th:last-child, table tr td:last-child { margin-bottom: 0; } #write strong { padding: 0 1px; } #write em { padding: 0 5px 0 2px; } #write table thead th { background-color: #f2f2f2; } #write .CodeMirror-gutters { border-right: none; } #write .md-fences { border: 1px solid #F4F4F4; -webkit-font-smoothing: initial; margin: 0.8rem 0 !important; padding: 0.3rem 0 !important; line-height: 1.43rem; background-color: #F8F8F8 !important; border-radius: 2px; font-family: var(--font-monospace); font-size: 0.85rem; word-wrap: normal; } #write .CodeMirror-wrap .CodeMirror-code pre { padding-left: 12px; } #write code, tt { padding: 2px 4px; border-radius: 2px; font-family: var(--font-monospace); font-size: 0.92rem; color: #e96900; background-color: #f8f8f8; } tt { margin: 0 2px; } #write .md-footnote { background-color: #f8f8f8; color: #e96900; } /* heighlight. */ #write mark { background-color: #EBFFEB; border-radius: 2px; padding: 2px 4px; margin: 0 2px; color: #222; font-weight: 500; } #write del { padding: 1px 2px; } .cm-s-inner .cm-link, .cm-s-inner.cm-link { color: #22a2c9; } .cm-s-inner .cm-string { color: #22a2c9; } .md-task-list-item > input { margin-left: -1.3em; } @media print { html { font-size: 13px; } table, pre { page-break-inside: avoid; } pre { word-wrap: break-word; } } .md-fences { background-color: #f8f8f8; } .md-diagram-panel { position: static !important; } #write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border: 0; border-radius: 3px; color: #777777; margin-top: 0 !important; } .mathjax-block > .code-tooltip { bottom: .375rem; } #write > h3.md-focus:before { left: -1.5625rem; top: .375rem; } #write > h4.md-focus:before { left: -1.5625rem; top: .285714286rem; } #write > h5.md-focus:before { left: -1.5625rem; top: .285714286rem; } #write > h6.md-focus:before { left: -1.5625rem; top: .285714286rem; } .md-image > .md-meta { border-radius: 3px; font-family: var(--font-monospace); padding: 2px 0 0 4px; font-size: 0.9em; color: inherit; } .md-tag { color: inherit; } .md-toc { margin-top: 20px; padding-bottom: 20px; } .sidebar-tabs { border-bottom: none; } #typora-quick-open { border: 1px solid #ddd; background-color: #f8f8f8; } #typora-quick-open-item { background-color: #FAFAFA; border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee; border-style: solid; border-width: 1px; } #md-notification:before { top: 10px; } /** focus mode */ .on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); } header, .context-menu, .megamenu-content, footer { font-family: var(--font-sans-serif); } .file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; } .mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); } .md-lang { color: #b4654d; } .html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; }"},{"title":"小程序第一次学习","path":"/2024/09/22/小程序第一次学习/","content":"和普通网页的差别运行环境 小程序运行在微信环境 API不同 无法调用DOM或者BOM的API 可以使用微信环境的API 开发模式 申请小程序开发账号 安装小程序开发者工具 创建和配置小程序 第一个小程序获取AppID在小程序的开发-&gt;开发设置里面找到 代码构成pages用来存放所有小程序的页面 utils用来存放工具性质的模块 app.js小程序项目的入口文件 app.json小程序的全局配置文件 app.wxss小程序的全局样式文件 project.config.json项目的配置文件 sitemap.json用来配置小程序机器页面是否允许被微信索引 小程序页面的组成部分pages中每个文件夹存放一个页面每个页面有四个基本文件组成 .js页面的脚本文件，存放页面的数据、事件处理函数等 .json当前页面的配置文件，配置窗口的外观，表现 .wxml .wxss页面的模板结构文件当前页面的样式表文件 json配置文件 项目根目录中的app.json配置文件 项目根目录中的project.config.json配置文件 项目根目录中的sitemap.json配置文件 每个页面文件夹中的.json配置文件 app.json配置文件包括小程序的页面路径，窗口外观，界面表现，底部tab等 project.config.json记录对开发工具所做的个性化配置 sitemap.json配置小程序的页面是否允许微信索引 WXML模板语法div&#x3D;&gt;viewtext&#x3D;&gt;spanimg&#x3D;&gt;imagea&#x3D;&gt;navigator&lt;navigator url=&quot;/pages/home/home&quot;&gt;&lt;/navigator&gt; 提供了类似于vue中的模板语法WXSS小程序的样式语言 新增了rpx尺寸单位 提供全局样式和局部样式 app.WXSS会作用于所有的小程序页面 局部页面的.WXSS样式仅对当前页面生效 WXSS仅支持部分CSS选择器 组件 视图容器 view scroll-view swiper和swiper-item 基础内容 text文本组件，类似于一个span元素。是一个行内元素 rich-text富文本组件，支持把HTML字符串渲染为WXML结构 表单组件 导航组件 媒体组件 map地图组件 canvas画布组件 开放能力 无障碍访问 API 事件监听类API 以on开头，用来监听某些事件的触发 同步API 以Sync结尾的API都是同步API 同步API的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常 异步API 给data中数据赋值通过调用this.setData(dataObject)方法，可以给data中的数据重新赋值 12345changeCount()&#123; this.setData(&#123; count: this.data.count + 1 &#125;)&#125; &lt;block&gt;不会渲染出来，不会占用内存，可以用来包含多个元素，同时控制他们渲染与否或者存不存在 事件传参&lt;button bindtap=&quot;btnHandler&quot; data-info=&quot;&#123;&#123;2&#125;&#125;&quot;&gt;事件传参&lt;/button&gt;在js中通过event.target.dataset.参数名即可获取到具体的参数的值 123btnHandler(e)&#123; console.log(e.target.dataset.info)&#125; input语法&lt;input bindinput=&quot;inputHandler&quot;&gt; 123inputHandler(e)&#123; console.log(e.detail.value)&#125;//获取表单当中的值 ## 实现数据双向绑定 `` 不使用{{}}语法，直接使用属性的名称来绑定（比较特殊） 可以使用索引和自定义索引名称来绑定key值 WXSS模板样式rpx用来解决屏幕适配的尺寸单位rpx把所有屏幕的宽度等分为750份，当前屏幕的总宽度为750rpx（开发微信小程序的时候，设计师可以用iphone6作为视觉稿的标准即1px &#x3D; 2 rpx） 样式导入@import &quot;common.wxss&quot;; 导入非本页面文件夹中的wxss文件 全局样式app.wxss中的样式就是全局样式 局部样式页面文件.wxss中的样式都是局部样式 局部样式和全局样式冲突的时候根据就近原则，局部样式就会覆盖全局样式 当局部样式的权重大于或者等于全局样式的时候，局部样式才会覆盖全局样式 下拉刷新实际开发中哪个页面需要用到下拉刷新再在对应的页面的配置文件里面去配置 上拉触底距离设置距离底部多少像素的时候刷新下一页（onReachBottomDistance） tabBar最少两个最多五个tab页签 底部tabBar 会显示icon和文本 顶部tabBar 只会显示文本不显示icon 网络数据请求 只能请求https类型的接口 必须先将接口的域名添加到信任列表当中 配置request合法域名登录微信小程序管理后台&#x3D;&gt;开发&#x3D;&gt;开发设置&#x3D;&gt;服务器域名&#x3D;&gt;修改request合法域名 发起GET请求使用wx.request()方法可以发起get数据请求 1234567891011wx.request(&#123; url:&#x27;接口地址&#x27;， method:&#x27;GET&#x27;, data:&#123; name:&#x27;ljl&#x27;, age:19 &#125;, success:(res) =&gt; &#123; console.log(res.data) &#125;&#125;) POST请求类似 1234567891011wx.request(&#123; url:&#x27;接口地址&#x27;， method:&#x27;POST&#x27;, data:&#123; name:&#x27;ljl&#x27;, age:19 &#125;, success:(res) =&gt; &#123; console.log(res.data) &#125;&#125;) 页面刚加载的时候自动请求在页面的onLoad事件中调用获取数据的函数 1234onLoad:function(options)&#123;this.getxxx(),this.getxxx()&#125; 小程序实现页面导航 声明式导航 页面上声明一个&lt;navigator&gt;导航组件通过点击实现页面跳转 编程式导航调用小程序的导航API，实现页面的跳转 声明式导航跳转到tabBar页面1&lt;navigator url=&quot;/pages/index/index&quot; open-type=&quot;switchTab&quot;&gt;&lt;/navigator&gt; url必须斜线开头，一定要写open-type=&quot;switchTab&quot; 跳转到非tabBar页面1&lt;navigator url=&quot;/pages/index/index&quot; open-type=&quot;navigate&quot;&gt;&lt;/navigator&gt; url必须斜线开头，要写open-type=&quot;navigate&quot;（可以省略不写） 后退导航 open-type的值必须是navigateBack，表示要进行后退导航 delta的值必须是数字，表示要后退的层级1&lt;navigator open-type=&quot;navigateBack&quot; delta=&#x27;1&#x27;&gt;返回上一页&lt;/navigator&gt; delta默认值是1 编程式导航导航到tabBar页面12345gotoIndex()&#123;wx.switchTab(&#123; url:&#x27;/pages/index/index&#x27;&#125;)&#125; 导航到非tabBar页面12345gotoIndex()&#123;wx.navigateTo(&#123; url:&#x27;/pages/index/index&#x27;&#125;)&#125; 后退导航使用wx.navigateBack()delta的默认值是1 导航传参 声明式导航传参 参数和路径之间用?分隔 参数键与参数值用&#x3D;相连 不同参数用&amp;分隔&lt;navigator url=&quot;/pages/index/index?name=joe&amp;age=20&quot;&gt;&lt;/navigator&gt; 编程式导航传参12345gotoIndex()&#123;wx.navigateTo(&#123; url:&#x27;/pages/index/index?name=ljl&amp;gender=male&#x27;&#125;)&#125; 无论是声明式还是编程式导航都可以通过onLoad:function(options)获取可以在data中声明一个query123456onLoad:function(options)&#123; console.log(options) this.setData(&#123; query:options&#125;)&#125; 页面事件下拉刷新S全局开启下拉刷新在app.json的window节点中，将enablePullDownRefresh设置为true 局部开启下拉刷新在页面的.json配置文件中，将enablePullDownRefresh设置为true通过onPullDownRefresh()函数即可监听当前页面的下拉刷新事件 关闭下拉刷新效果wx.stopPullDownRefresh()可以关闭下拉刷新效果 上拉触底手指上拉加载更多数据 监听上拉触底事件在页面的.js问价，通过onReachBottom()函数即可监听当前页面的上拉触底事件，实例代码如下 123onReachBottom:function()&#123; console.log(&#x27;触发了上拉触底事件&#x27;)&#125; 配置上拉触底距离通过onReachBottomDistance属性来配置上拉触底的距离 加载通过wx.showLoading来显示加载通过wx.hideLoading来隐藏加载 组件自定义组件全局引用在app.json 中使用usingComponents:&#123;&#125;来实现全局引用 组件处理函数需要定义到methods节点当中 样式隔离在app.wxss当中定义的类的全局样式对组件无效只有class选择器有样式隔离的效果，别的选择器不受样式隔离的影响"},{"title":"寒假实训经验回顾","path":"/2024/09/22/寒假实训经验回顾/","content":"寒假实训经验回顾梁建麟 寒假实训项目介绍我寒假进行的实训项目是一个贺卡棋类的小程序，这个小程序开发的意图就是为了让亲朋好友之间相互投递祝福以及投递贺卡，在棋盘页面也可以通过投骰子到特定的格子上面触发特定的效果。例如获得贺卡祝福触发机会牌等等。 开发过程在开发的过程中，先是在等待产品稿和视觉稿的同时学习了开发小程序的一些知识，对于小程序的一些感受就是真的既方便又随便，方便指的是提供了许多的可用的接口，但是随便的指的就是随随便便就会废弃接口，一些一两年前的代码甚至就不太能参考了（你以为你是腾讯就可以为所欲为吗.jpg）。在产品稿出来之后我们就开始动工了，但是因为我是第一次协作，也是第一次线上协作开发，大家生活中的事情也实在不少（忙，忙点好啊）再加上过年，过年那几天嘛懂的都懂，所以在各方面进展缓慢，我检讨（自罚看一集迷宫饭，都给我去看迷宫饭）。在开学第一周才大致竣工，不过在视觉稿方面有些不尽如人意，所以一直没有去搞样式的事情。然后在开学第一周周六就开始和后端搞这搞那，尝试着添加了一些代码，也面对了一些有关form-data的传输以及本地缓存的问题。样式啊，样式也是到最后才匆匆开始搞，对不起后端的小伙伴啊😭😭😭 项目所用的技术这要我怎么说呢，大概就是小程序和jwt这些？感觉微信开发者工具确实是很适合初学者来学的，因为总感觉会有很多的既视感，经常会有咦，这个，噢，这样的感觉。 经验我认为这一次学习的经验对于我来说还是特别宝贵的，在这次的实训过程中，我明白了和组员之间经常沟通，在一些地方上进行统一的重要性，这样子可以加快我们组内每个人阅读别人所写代码的效率（没有黑屁的意思，但是lxq的代码看的我真的是有点）。也学到了应该要经常和后端沟通关于接口的事情，不然到后面真的是改到想似。以及如果有一些经常要用到的代码的话最好是可以把它单独写成一个工具啦。不然到后面维护和修改起来真的会头大。 亮点我想了半天我们最大的亮点应该就是图片的上传以及缓存？以下是缓存图片的代码这是对比两个存储图片url的数组除去相同对象并且缓存的数组 1const iconRes = await setCache( this.removeDuplicates(this.data.icons,res.data),this.data.icons.length) 通过对比数组中每一个对象的url利用过滤器除去相同的对象 1234removeDuplicates(arr1, arr2) &#123; let res = arr2.filter(obj2 =&gt; !arr1.some(obj1 =&gt; obj1.url === obj2.url)) return res &#125; , 将数组中每一个url中的图片进行下载，并且借助传进来的长度来设置id并且返回一个新的数组。 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; baseUrl &#125; from &quot;./index&quot;; export const setCache = async function images(urls,l) &#123; const promises = urls.map((url, i) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; wx.downloadFile(&#123; url: baseUrl + url.url, // 图片的URL success: function(res) &#123; wx.getFileSystemManager().saveFile(&#123; tempFilePath: res.tempFilePath, success: function(savedRes) &#123; console.log(&quot;缓存成功&quot; + baseUrl + url.url); resolve(&#123; url:savedRes.savedFilePath, id:i + l &#125;); &#125;, fail: function(err) &#123; console.log(err); reject(err); &#125; &#125;); &#125;, fail: function(err) &#123; console.log(err); reject(err); &#125; &#125;); &#125;); &#125;); try &#123; const savedFilePaths = await Promise.all(promises); console.log(&quot;保存结束&quot;); console.log(savedFilePaths); return savedFilePaths; &#125; catch (error) &#123; console.error(&quot;Error saving images&quot;, error); return []; &#125; &#125;; 省略了一些些细节，在上面的一套连招过后，每一次渲染的都会是已经存储过的图片的，如果没有上传新的图标以及背景什么的是不会重新发起请求的，而且就算发起请求也只是请求刚上传的图片。 遇到的问题我认为主要的问题还是在棋盘，jwt和form-data的传输上面 棋盘在棋盘的处理上面我觉得我做的有一些过分得怎么说呢，过分原始了。下面是一些我写的极为逆天的运动和定位的逻辑。通过一个数组保存不同格子的坐标，这个就得靠一些毅力和尝试了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051checkers:[ &#123; x:125, y:335 &#125;,&#123; x:250, y:335 &#125;,&#123; x:375, y:335 &#125;,&#123; x:500, y:335 &#125;,&#123; x:500, y:470 &#125;,&#123; x:500, y:595 &#125;,&#123; x:500, y:715 &#125;,&#123; x:500, y:845 &#125;,&#123; x:500, y:965 &#125;,&#123; x:375, y:965 &#125;,&#123; x:250, y:965 &#125;,&#123; x:125, y:965 &#125;,&#123; x:125, y:845 &#125;,&#123; x:125, y:715 &#125;,&#123; x:125, y:595 &#125;,&#123; x:125, y:470 &#125;, ] 以下是棋子移动的逻辑，通过递归和定时器来实现间断的移动，判断停止类的。通过设置棋子位置改变的动画时间长短来实现棋子一格一格移动的效果。 12345678910111213141516171819202122232425262728pieceMove(curPos,pos)&#123;if(curPos - 1 == pos)&#123; this.setData(&#123; isDiceDisabled:false &#125;) if(pos == 3||pos == 5||pos == 9||pos == 12||pos == 14)&#123; this.chanceHandler() &#125; if(pos == 2|| pos == 4|| pos == 8|| pos == 13)&#123; this.getGreeting(1) &#125; if(pos == 1|| pos == 6|| pos == 10)&#123; this.getGreetingCard(1) &#125; return&#125;if(curPos == 16)&#123; curPos = 0&#125;this.setData(&#123; position:pos, positionX:this.data.checkers[curPos].x, positionY:this.data.checkers[curPos].y&#125;)setTimeout(()=&gt;&#123; this.pieceMove(curPos + 1,pos)&#125;,300)&#125; 以上就是我给大家的一些反面教材，在布局的改变以及在一些修改上面就可能要了别人的老命，真的是究极体力活啊，最有力的一集。希望jrm可以给出一些修改的建议。我现在想着好像可以通过网格布局啥的来进行布局？但是还没有付诸实践过。我也希望大家可以给我一些建议~ jwt在前端获得token之后需要通过解析获得例如id等等的信息，这是什么我上网，纳尼，他们说好像不能解析？难道这要是自己写吗？不过我还是在英特网上找到了别人写好的js。 form-data在前后端联调的时候后端突然说需要在请求体中要使用form-data格式，啊？这怎么搞呢，我尝试了多种办法都没法解决，到后反而是靠修改后端才终于解决了这个问题，但是小程序到底怎么发form-data格式的内容呢？我现在还是没有解决这个问题。"},{"title":"修饰符","path":"/2024/09/22/修饰符/","content":"what is 修饰符在vue中，修饰符处理了很多DOM事件的细节，可以让我们专注于逻辑处理和方法实现，免于疲于DOM事件的细节vue中修饰符主要分为以下五类： 表单修饰符 事件修饰符 鼠标按键修饰符 键值修饰符 v-bind修饰符 常见的修饰符表单修饰符 lazy trim number lazy 默认情况下，v-model会在每次input事件更新数据。可以通过添加lazy修饰符来改为在每次change事件之后更行数据： 12&lt;input type=&quot;text&quot; v-model.lazy=&quot;value&quot;&gt;&lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; trim 可以通过在v-model后添加.trim修饰符来自动去除用户输入内容中两端的空格： 1&lt;input type=&quot;text&quot; v-model.trim=&quot;value&quot;&gt; number 可以自动把用户输入的内容转换为数字： 1&lt;input type=&quot;number&quot; v-model.number=&quot;age&quot;&gt; 事件修饰符 stop prevent self once capture passive native stop 使用.stop可以阻止点击事件冒泡： 123&lt;div @click=&quot;divClick&quot;&gt; &lt;button @click.stop=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 这样在点击按钮的时候就不会触发到父元素的divClick事件2. prevent 阻止了事件的默认行为，例如提交事件之后不会再重新加载页面，再例如点击链接之后不会自动跳转到对应的页面： 12&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;aClick&quot;&gt;点击不跳转&lt;/&gt; self 仅当事件处理的目标是元素本身的时候才会触发事件处理器，例子： 123456789id=&quot;_Red&quot; v-on:click=&quot;doThat1(event)&quot; style=&quot;width: 500px;height: 500px;background: red;&quot;&gt; &lt;div v-on:click=&quot;doThat(event)&quot; id=&quot;_Blue&quot; style=&quot;width: 200px;height: 200px;background: blue;&quot;&gt; &lt;/div&gt; &lt;/div&gt; vue 实例方法 12345678910doThat:function(e)&#123; alert(&#x27;doThat&#x27;+$(e.target).attr(&#x27;id&#x27;)); &#125;,doThat1:function(e)&#123; alert(&#x27;doThat1&#x27;+$(e.target).attr(&#x27;id&#x27;)); &#125; 没有添加修饰符的时候，点击blue部分的输出结果是： 123doThat_BluedoThat1_Blue//这里要说明一下，事件冒泡除了事件触发以外传入的事件对象也是事件源的对象，并非是事件绑定的元素，因此两次输出的都是Blue而不是一次Blue一次Red 当我们再Red上加上.self修饰符的时候再点击Blue就会发现只输出了doThat_Blue就不会再输出了，因为.self只执行直接作用在该元素上的事件。注意：使用修饰符时需要注意调用顺序，使用@click.prevent.self会阻止元素及其子元素的所有点击事件的默认行为而@click.self.prevent则只会阻止对元素本身的点击事件的默认行为。4. once 绑定了事件以后就只能触发一次，第二次就不会触发了。 1&lt;button @click.once=&quot;shout(1)&quot;&gt;ok&lt;/button&gt; capture 当元素发生冒泡时先处理带有.capture的事件，如果有多个事件带有该修饰符则从外向内逐个处理，而没有带该修饰符的就会从内向外处理： 12345678910111213 &lt;div @click.capture=&quot;shout(1)&quot;&gt; obj1&lt;div @click.capture=&quot;shout(2)&quot;&gt; obj2&lt;div @click=&quot;shout(3)&quot;&gt; obj3&lt;div @click=&quot;shout(4)&quot;&gt; obj4&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;// 输出结构: 1 2 4 3 6. passive 在移动端，当我们在监听元素滚动的时候，会一直触发onscroll事件让我们的网页变卡，在使用了这个修饰符之后就相当于给onscroll事件添加了一个.lazy修饰符。 .passive修饰符一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能。注意：不要同时使用.passive和.prevent7. native 让组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件 1&lt;my-component v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt; 鼠标按钮修饰符鼠标按钮修饰符针对的就是左键，中键，右键点击，有如下： left 左键点击 right 右键点击 middle 中间点击 123&lt;button @click.left=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;&lt;button @click.right=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;&lt;button @click.middle=&quot;shout(1)&quot;&gt;ok&lt;/button&gt; 键盘修饰符键盘修饰符就是用来修饰键盘事件的，用来检查特定的键盘按键，我们可以在v-on或者@监听按键事件的时候添加按键修饰符。 1234//仅在 `key` 为 `Enter` 时调用 `submit`，同理可以使用别的按键别名&lt;input @keyup.enter=&quot;submit&quot; /&gt;&lt;input @keyup=&quot;submit&quot; /&gt;//在按下键盘任意键的时候触发事件 按键别名 .enter .tab .delete(Delete or Backspace) .esc .up .down .left .right 系统按键修饰符 .ctrl .alt .shift .meta(windows里面就是windows键) 举例来说： 12345&lt;!-- Alt + Enter --&gt;&lt;input @keyup.alt.enter=&quot;clear&quot; /&gt;&lt;!-- Ctrl + 点击 --&gt;&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt; .exact修饰符12345678&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt; v-bind修饰符有 async prop camel 等，不太懂其意义，以后再说吧"},{"title":"vue小记","path":"/2024/09/22/小记（1/","content":"计算属性缓存将同样的函数定义为方法而不是计算属性时，两种方法的结果上时一致的，而计算属性会基于其响应式依赖被缓存只有在其响应式依赖变更的时候才会重新计算，但是方法在每次访问的时候都会重复执行函数。 样式绑定绑定数组我们可以通过给:class绑定一个数组来渲染多个css 1&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt; 相应的，也能在数组里面用对象或者三目表达式来进行有选择的渲染 123&lt;div :class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;//`isActive`为真时active被渲染&lt;div :class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;//errorClass会一直存在 组件绑定 根元素 在给组件绑定时，如果组件只有一个根元素，那么就会直接给这个根元素渲染 当有多个根元素时，就可以通过@attrs属性来实现指定： 123&lt;!-- MyComponent 模板使用 $attrs 时 --&gt;&lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;&lt;span&gt;This is a child component&lt;/span&gt; 1&lt;MyComponent class=&quot;baz&quot; /&gt; 会被渲染成： 12&lt;p class=&quot;baz&quot;&gt;Hi!&lt;/p&gt;&lt;span&gt;This is a child component&lt;/span&gt; 内联样式:style支持绑定javascript对象值，对应的时html元素的style属性： 12const activeColor = ref(&#x27;red&#x27;)const fontSize = ref(30) 1&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; 绑定对象可以通过直接绑定一个对象来使模板更加简洁： 1234const styleObject = reactive(&#123; color: &#x27;red&#x27;, fontSize: &#x27;13px&#x27;&#125;) 1&lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt; 绑定数组可以通过绑定多个数组来合并并且渲染到同一个元素上面： 1&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 列表渲染12345678&lt;li v-for=&quot;&#123; message &#125; in items&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/li&gt;&lt;!-- 有 index 索引时 --&gt;&lt;li v-for=&quot;(&#123; message &#125;, index) in items&quot;&gt; &#123;&#123; message &#125;&#125; &#123;&#123; index &#125;&#125;&lt;/li&gt; 单大括号内与对象的属性名保持一致 v-for与对象你也可以使用 v-for 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 Object.keys() 的返回值来决定。 12345const myObject = reactive(&#123; title: &#x27;How to do lists in Vue&#x27;, author: &#x27;Jane Doe&#x27;, publishedAt: &#x27;2016-04-10&#x27;&#125;) 12345&lt;ul&gt; &lt;li v-for=&quot;value in myObject&quot;&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 第二个参数表示属性名，第三个参数表示位置索引 123&lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/li&gt; v-if 与 v-for同一个节点上，v-if的优先级比v-for高，所以将无法读取到别名 1234567&lt;!-- 这会抛出一个错误，因为属性 todo 此时 没有在该实例上定义--&gt;&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo.name &#125;&#125;&lt;/li&gt; 方法事件处理器v-on可以接收一个函数名来对函数调用 123456789const name = ref(&#x27;Vue.js&#x27;)function greet(event) &#123;//event可以删去 alert(`Hello $&#123;name.value&#125;!`) // `event` 是 DOM 原生事件 if (event) &#123;//当事件发生时 alert(event.target.tagName)//event.target.tagName访问dom元素 &#125;&#125; 12&lt;!-- `greet` 是上面定义过的方法名 --&gt;&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt; 一点例子1234567891011&lt;script setup&gt;defineProps([&#x27;title&#x27;])defineEmits([&#x27;remove&#x27;])&lt;/script&gt;&lt;template&gt; &lt;li&gt; &#123;&#123; title &#125;&#125; &lt;button @click=&quot;$emit(&#x27;remove&#x27;)&quot;&gt;Remove&lt;/button&gt; &lt;/li&gt;&lt;/template&gt;"},{"title":"学线前端第一次例会正式学习文档","path":"/2024/09/22/第一次正式例会学习/","content":"有关vue组合式API 由于自学的时候我学的是选项式API，所以现在需要学习组合式，组合式简单了许多，甚至不需要default export，真方便挺多的，牛魔的 在组合式API中，使用ref()函数来声明响应式状态 1234&lt;script setup&gt;//在script中添加一个`setup`以实现响应式import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0); 用ref()函数接收参数，将其包裹在一个带有.value属性的ref对象中返回： 12345console.log(count) // &#123; value: 0 &#125;console.log(count.value) // 0count.value++console.log(count.value) // 1 所以当使用了ref()时，要使用这个值一定要记得加.value而方法等可以直接使用js中的语法，不需要通过methods :包裹在&lt;script setup&gt;...&lt;/script&gt;中可以用import Component from &#39;./components/Component.vue&#39;语句来引用组件，不需要再注册了。而且在父组件之中可以把一个子组件的名字当作标签来使用，此时这个子组件的内容就可以正常显示出来。 计算属性以及解析赋值语法在&lt;script setup&gt;...&lt;/script&gt;中记得import &#123; computed &#125; from &#39;vue&#39;而当有别的需要通过从vue引用时，例如生命周期钩子函数时，可以一并写成: 1import &#123; ref, computed, onMounted &#125; from &#x27;vue&#x27; 以下是使用计算属性的一个实例： 12345678910111213const fullName = computed(&#123; // getter get() &#123; return firstName.value + &#x27; &#x27; + lastName.value &#125;, // setter set(newValue) &#123; // 注意：我们这里使用的是解构赋值语法 const arr = newValue.split(&#x27; &#x27;) firstName.value = arr[0] lastName.value = arr[arr.length - 1] &#125;&#125;) 注意： 这里的get()和set()在使用时不需要另外加上，在调用fullName即自动调用了get()函数，而在fullName = &#39;Tony Stark&#39;时就会自动调用set()函数，这里的&#39;Tony Stark&#39;可以是任何文本。 解构赋值法：通过.split()函数将一段字符串分开储存在一个数组之中，并赋值给firstName和lastName，而后在set()中就会将数据处理然后返回，强调一下需要const firstName = ref(&#39;John&#39;) const lastName = ref(&#39;Doe&#39;)来实现响应式。 计算属性一般是只读的，但是当我们添加了一个get()之后可以通过fullName = &#39;Tony Stark&#39;来进行修改。 生命周期钩子函数每个vue组件实例在被创建的时候都会经历一系列的初始化步骤，在此过程中就会运行被称为生命周期钩子的函数，让开发者可以在特定阶段运行自己的代码。 注册周期钩子1234567&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;//可以和ref,computed等放在一起onMounted(() =&gt; &#123; console.log(`the component is now mounted.`)&#125;)&lt;/script&gt; 一些现在不懂但是应该很重要的东西当调用 onMounted 时，Vue 会自动将回调函数注册到当前正被初始化的组件实例上。这意味着这些钩子应当在组件初始化时被同步注册。例如，请不要这样做： 123456setTimeout(() =&gt; &#123; onMounted(() =&gt; &#123; // 异步注册时当前组件实例已丢失 // 这将不会正常工作 &#125;)&#125;, 100) 注意这并不意味着对 onMounted 的调用必须放在 setup() 或 &lt;script setup&gt; 内的词法上下文中。onMounted() 也可以在一个外部函数中调用，只要调用栈是同步的，且最终起源自 setup() 就可以。 有关npm在一个项目中需要使用到各种依赖包，我们可以在npm官网查看依赖的名字，作用，还能通过学习官方文档来使用依赖因为一般使用的是vscode，所以这里直接用vscode来举例，进入到项目的文件夹过后，点开查看&gt;终端，然后输入命令行npm install 文件名来下载依赖，在vue项目中可以在package.json中看到我们使用的依赖。"},{"title":"第一次自己学vue文档","path":"/2024/09/22/第一次学习文档/","content":"项目结构目前需要了解的 package.json文件中包含的是项目的依赖列表 index.htmlvue应用会通过这个文件进行运行 src是vue应用的核心代码目录 main.js:会初始化vue应用并决定将什么应用挂载到哪个HTML元素上面 App.vue：是vue应用的根节点组件 components：用来存放自定义的组件的目录 assets：这个目录用来存放css和图片的静态资源 App.vueApp.vue中能看到&lt;template&gt;,&lt;script&gt;,&lt;style&gt;三部分，分别包含了组件的模板，脚本和样式相关内容。 &lt;template&gt;包含了所有的标记结构和组件的展示结构，可以包含任何合法的HTML以及vue特定的语法。 &lt;script&gt;包含了组件中的非现实逻辑，但是最重要的是，这个标签要默认导出一个js对象。该对象是你在本地注册组件、定义属性、处理本地状态、定义方法的地方。 main.js12345import &#123; createApp &#125; from &#x27;vue&#x27;//起手式，无需多言，主要是我不知道怎么说import App from &#x27;./App.vue&#x27;//从一个单文件组件导入根组件import &quot;./assets/reset.css&quot;;//导入css文件createApp(App).mount(&#x27;#app&#x27;)//创建一个vue应用并且并且将其挂载起来供HTML使用 组件中&lt;script&gt;内的内容12345678910111213141516171819import ToDoForm from &quot;./components/ToDoForm.vue&quot;;//在注册组件之前需要导入//以下是组件的默认导出内容export default &#123; name: &#x27;App&#x27;//App填写的是组件的 components: &#123; ToDoForm//用来注册组件，和vue文件名称一致 &#125;, data()&#123; return &#123; ToDoItem:&#x27;&#x27;//需要使用到数据，在：对其进行赋值 &#125;, &#125;; methods :&#123; //这里写方法和逻辑 &#125; //还有props和钩子函数以及计算等，等待后面的学习ing&#125; 自定义元素要在应用程序中实际展示 ToDoItem 组件，你需要在 &lt;template&gt; 模板内添加一个 &lt;to-do-item&gt;&lt;/to-do-item&gt; 元素。请注意，组件文件名及其在 JavaScript 中的表示方式总是用大写驼色（例如 ToDoList），而等价的自定义元素总是用连字符小写（例如 &lt;to-do-list&gt;）。 模板语法文本插值&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;双大括号标签中的 msg会被替成相应组件实例中的msg的值，而且每次msg属性改变它也会同步更行这么一想还怪好用的嘞 v-html双大括号会将数据解释为纯文本，而不是HTML。可以使用v-html指令进行插入： 12&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; Attribute如果想要响应式地绑定一个attribute可以通过v-bind进行 1&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 通过v-bind指令将id和dynamicId保持一致，实现响应式的绑定 简写1&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 用:来代替v-bind: 布尔型Attribute布尔型Attribute依据true&#x2F;false决定该attribute是否应该存在在这个元素上&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;当isButtonDisabled为真值或者一个字符串的时候，元素会包含这个attribute。而当为其他或者假值时该attribute将会被忽略 动态绑定多个值12345678data() &#123; return &#123; objectOfAttrs: &#123; id: &#x27;container&#x27;, class: &#x27;wrapper&#x27; &#125; &#125;&#125; 这是一个包含有多个Attribute的javascript对象可以通过不带参数的v-bind来将其绑定到单个元素上：&lt;div v-bind=&quot;objectOfAttrs&quot;&gt;&lt;/div&gt; 使用javascript表达式vue在数据绑定还支持完整的javascript表达式： 1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;div :id=&quot;`list-$&#123;id&#125;`&quot;&gt;&lt;/div&gt; vue模板中在以下场景可以使用JavaScript表达式： 在文本插值中 在以v-为开头的特殊attribute值中。 仅支持表达式12345&lt;!-- 这是一个语句，而非表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 条件控制也不支持，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 可以调用函数123&lt;time :title=&quot;toTitleDate(date)&quot; :datetime=&quot;date&quot;&gt; &#123;&#123; formatDate(date) &#125;&#125;&lt;/time&gt; 内置指令 指令 期望的绑定值类型 作用 v-text string 等同于&#123;&#123;&#125;&#125;对文本进行插值 v-html string 作为HTML值进行插入（最好不用） v-show any 基于表达式的真假性来改变元素的可见性（不会对元素有删除操作） v-if any 基于表达式的真假性来有条件地对元素或者模板片段进行渲染（会对元素有删除操作） v-else 无需输入值 表示v-if或者v-if&#x2F;v-else-if链式调用的else块，上一兄弟元素必须有v-if或者v-else-if v-else-if any 作为else if块被调用，上接v-if或者v-else-if v-for Array&#x2F;Object&#x2F;number&#x2F;string&#x2F;Iterable 基于原始数据地多次渲染元素或者模板快 v-on Function&#x2F;Inline Statements&#x2F;Object 给元素绑定事件监听器(缩写@) v-bind any&#x2F;Object（不带参数） 动态绑定attribute v-model 根据表单的输入元素和组建的输出值而改变 在表单输入元素或组件上创建双向绑定。 多次渲染实例123&lt;div v-for=&quot;item in items&quot;&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt; 监听实例1234567$emit(&quot;todo-added&quot;,this.data)//子组件向父组件传值，其中&quot;todo-added&quot;可以在父组件中绑定事件，this.data则为传递的数据&lt;to-do-form @todo-added=&quot;addToDo&quot;&gt;&lt;/to-do-form&gt;methods:&#123; addToDo(Data)&#123;运行代码//其中Data就是this.data传输来的数据&#125;,&#125;; 实例其二 1234567 &lt;button type=&quot;submit&quot; v-on:click=&quot;$emit(&#x27;deleted&#x27;)&quot; class=&quot;btn-del&quot;&gt;Delete&lt;/button&gt;//子组件@deleted=&quot;deleteItem(item.id)&quot;//在父组件的自定义标签中添加deleteItem(toDoId)&#123; let toDoToUpdate = this.ToDoItems.find((item) =&gt; item.id === toDoId); toDoToUpdate.show = !toDoToUpdate.show; localStorage.setItem(&#x27;ToDoItems&#x27;, JSON.stringify(this.ToDoItems)); &#125;,//script中的方法 下一次学习目标: props以及更多组件实例 v-slot以及更多vue的内置指令 插槽 动态参数 修饰符 计算属性 生命周期钩子函数"},{"title":"学线前端第三次例会正式学习文档","path":"/2024/09/22/第三次正式例会/","content":"项目结构（新的）components用来装子组件的 assets用来装css图片等资源 router有一个index.js用来装不同的url路径对应的处理函数以及所对应的挂载的组件 store里面装的是一个用来存储不同网页的共同使用的资源的文件 views里面装的是组件的视窗部分，就是给路由用的 reactive和ref函数 ref reactive 数据类型 原始数据、对象 对象 操作 js中需要添加.value，tamplate中则不用 都不用添加.value watch监听1234watch(count, (newCount, oldCount) =&gt;&#123; console.log(`count change from $&#123;oldCount&#125; to $&#123;newCount&#125;`);&#125;)//count 的位置可以填对象，基本数据，计算属性等 立即执行123456789watch( zzy, () =&gt; &#123; console.log(&quot;zzy changed&quot;); &#125;, &#123; immediate: true, &#125;); 深度监听当你监听的是一个对象而且没有进行深度监听的时候，当对象的某个属性值改变的时候是不会触发监听事件的。这个时候就要加上一个&#123;deep:true,&#125; 123456789watch( zzy, (newZzy, prevZzy) =&gt; &#123; console.log(`zzy changed from $&#123;prevZzy.age&#125; to $&#123;newZzy.age&#125;`); &#125;, &#123; deep: true, &#125;); 多重监听主要是把单个名字改成一个数组形式， 12345678910watch( [count, zzy], ([newCount, newZzy], [prevCount, prevZzy]) =&gt; &#123; console.log(`多重监听count changed from $&#123;prevCount&#125; to $&#123;newCount&#125;`); console.log(`多重监听zzy changed from $&#123;prevZzy.age&#125; to $&#123;newZzy.age&#125;`); &#125;, &#123; deep: true, &#125;); 监听单个属性123456watch( () =&gt; zzy.value.age, (newAge, prevAge) =&gt; &#123; console.log(`zzy.age changed from $&#123;prevAge&#125; to $&#123;newAge&#125;`); &#125;); 使用箭头函数作为watch的回调函数可以让我们再函数内部访问到变化前后的属性值 templateRef 需要在你想要调用的元素的标签名里面加上ref = index（这是一个别名） 在&lt;script setup&gt;里面写上const index = ref(null)这里写上null并没关系。 调用templateRef1234567891011121314151617&lt;div ref=&quot;index&quot;&gt; &lt;h1&gt;templateRef模板引用&lt;/h1&gt; &lt;p&gt;打开控制台查看&lt;/p&gt; &lt;/div&gt;//以下是scriptimport &#123;ref&#125; from &#x27;vue&#x27;const index = ref(null)function handleClick() &#123; console.log(index.value)&#125;//以下是在控制台的输出结果&lt;div ref=&quot;index&quot;&gt; &lt;h1&gt;templateRef模板引用&lt;/h1&gt; &lt;p&gt;打开控制台查看&lt;/p&gt; &lt;/div&gt; 实现dom树的修改 1234function changeColor() &#123; if(index.value.style.color == &#x27;red&#x27;)index.value.style.color = &#x27;blue&#x27; else index.value.style.color = &#x27;red&#x27;&#125; 父子组件通信子组件向父组件传输数据defineEmits12345const emit = defineEmits([&#x27;pass-msg-to-father&#x27;])const msg2 = ref(666)onMounted(()=&gt;&#123; emit(&#x27;pass-msg-to-father&#x27;, msg2)&#125;) 注意：这里emit不可以随便修改，两个都是！在父组件中子组件的标签内用@pass-msg-to-father = &quot;getMagFromSon&quot;自己定义的一个方法名在&lt;script setup&gt;中添加 1234const msg2 = ref(&#x27;&#x27;)const getMagFromSon = (data) =&gt; &#123; msg2.value = data.value&#125; 来实现子组件向父组件的通信当然，这里的data也是一个别名 defineExpose（学长甄选，更加符合直觉，我也是这么觉得滴）1234defineExpose(&#123; sonMsg, changeSonMsg&#125;) 这里的sonMsg和changeSonMsg等就是已经在子组件已经定义的变量和函数然后再在父组件的script里面加上这几句,其实就是你平时怎么用就怎么用就好了 123456const getMsgFromSon2 = () =&gt; &#123; console.log(son2.value.sonMsg) son2.value.changeSonMsg() son2Msg.value = son2.value.sonMsg console.log(son2.value.sonMsg)&#125; 父组件向子组件的通信defineProps在子组件当中创建一个props对象 123456const props = defineProps(&#123; msg: &#123; type: Number, required: true &#125;&#125;) 这里的defineProps就相当于给子组件添加了新的属性然后再在父组件当中的子组件标签当中用v-bind实现双向绑定，然后再再父组件中添加const msg = ref(0)等语句就可以实现父组件给子组件传值。 祖孙组件传值provide and inject 12345678import &#123; provide, ref &#125; from &#x27;vue&#x27;;const count = ref(0);const addCount = () =&gt; &#123; count.value++;&#125;provide(&#x27;count&#x27;, count);provide(&#x27;addCount&#x27;, addCount); 只要在祖组件当中使用过一次provide子组件和孙组件等只需要inject就可以共享使用变量和方法了 1234567&lt;script setup&gt;import sonComponent from &#x27;./sonComponent.vue&#x27;;import &#123; inject &#125; from &#x27;vue&#x27;;const count = inject(&#x27;count&#x27;);const addCount = inject(&#x27;addCount&#x27;);&lt;/script&gt; 123456&lt;script setup&gt;import &#123; inject &#125; from &#x27;vue&#x27;;const count = inject(&#x27;count&#x27;);const addCount = inject(&#x27;addCount&#x27;);&lt;/script&gt; 然后只要按照平时使用变量和函数的方法正常使用就没有问题了 pinia是vue专属的最新的状态管理库，允许跨组件或页面来共享数据的状态 添加pinia项目 命令行添加依赖npm install pinia 在入口文件main.js中引入Pinia123import &#123; createPinia &#125; from &#x27;pinia&#x27;//别的乱七八糟app.use(createPinia()) 使用pinia项目要在专门的store文件夹里面添加不同的文件 12345678910111213import &#123; ref, computed &#125; from &#x27;vue&#x27;import &#123; defineStore &#125; from &#x27;pinia&#x27;export const useCounterStore = defineStore(&#x27;counter&#x27;, () =&gt; &#123; const count = ref(0) const doubleCount = computed(() =&gt; count.value * 2) function increment() &#123; count.value++ &#125; const decrement = () =&gt; count.value-- return &#123; count, doubleCount, increment, decrement &#125;&#125;) 注意: useCounterStore位置是实际引用的时候会使用到的名称 在const前要记得加上export，导入之前自然要先导出，没有疑问的 回调函数的最后记得将需要导出的变量和方法名return出来。 在组件中使用 123456&lt;script setup&gt;import &#123;useCounterStore&#125; from &#x27;@/stores/counter&#x27;const counterStore = useCounterStore()&lt;/script&gt; 然后正常使用就可以了，比如需要用count直接写counterStore.count想要使用，想要使用increment方法就可以直接写counterStore.increment 实践在实际使用的时候只要在创建vue项目的时候选择添加pinia就可以了 router添加router项目创建一个router文件夹，这个文件夹和组件store等在同一层然后在router文件夹里面创建一个index.js文件 index.js在index.js的开头记得加上import &#123; createRouter, createWebHistory &#125; from &#39;vue-router&#39; 12345678910111213141516171819202122const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), routes: [ &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: refAndReactive &#125;, &#123; path: &#x27;/refAndReactive&#x27;, name: &#x27;refAndReactive&#x27;, component: refAndReactive &#125;, &#123; path: &#x27;/computedAndWatch&#x27;, name: &#x27;computedAndWatch&#x27;, component: () =&gt; import(&#x27;../views/computedAndWatch.vue&#x27;) &#125;, ]&#125;)export default router 这是路由的模板，有两种挂载组件的方法，可以在一开始导包import refAndReactive from &#39;../views/refAndReactive.vue&#39;然后在路由当中用component: refAndReactive直接挂载，但是如果每次都一次性导包，效率未免有些低，所以可以用component: () =&gt; import(&#39;../views/computedAndWatch.vue&#39;)让其在实际使用的时候才挂载起来 组件中使用1234567891011121314151617181920212223242526272829303132333435import &#123; RouterLink, RouterView &#125; from &#x27;vue-router&#x27;const List = [ &#123; url:&#x27;/refAndReactive&#x27;, name: &#x27;响应式和ref与reactive&#x27; &#125;, &#123; url:&#x27;/computedAndWatch&#x27;, name: &#x27;computed和watch&#x27; &#125;, &#123; url:&#x27;/tamplateRef&#x27;, name: &#x27;templateRef模板引用&#x27; &#125;, &#123; url:&#x27;/lifeCycle&#x27;, name: &#x27;生命周期函数&#x27; &#125;, &#123; url: &#x27;/defineProps&#x27;, name: &#x27;父子组件通信&#x27; &#125;, &#123; url: &#x27;/provideAndInject&#x27;, name: &#x27;祖孙组件通信&#x27; &#125;, &#123; url: &#x27;/pinia&#x27;, name: &#x27;pinia&#x27; &#125;, &#123; url: &#x27;/router&#x27;, name: &#x27;router&#x27; &#125;] 从vue-router导入RouterLink和RouterView等，然后创建一个数组，存储url和name然后使用 1&lt;router-link :to=&quot;item.url&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/router-link&gt; 来创建链接实现跳转，item.url就是要跳转的url不过是在App.vue的基础上跳转的，item.name就是相对的名字等 1&lt;router-view&gt;&lt;/router-view&gt; 这个就是用来展示views的视窗 v-on绑定1&lt;button @click=&quot;$router.push(&#x27;/refAndReactive&#x27;)&quot;&gt;点击返回refAndReactive&lt;/button&gt; 使用v-on绑定事件$router.push(&#39;url&#39;)就可以直接跳转到对应的页面 useRouter12345678&lt;script setup&gt;import &#123; useRouter &#125; from &#x27;vue-router&#x27;const router = useRouter()const toPage = (url) =&gt; &#123; router.push(url)&#125;&lt;/script&gt; 1&lt;button @click=&quot;toPage(&#x27;/computedAndWatch&#x27;)&quot;&gt;点击返回computedAndWatch&lt;/button&gt; &#39;/computedAndWatch&#39;处也是填入对应的url"}]